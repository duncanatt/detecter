{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the detectEr tutorial! \u00b6 What is detectEr? \u00b6 detectEr is a runtime verification tool for asynchronous component systems that run on the Erlang Virtual Machine. It also supports monitoring systems that can execute outside of the EVM, so long as these can produce traces that are formatted in a way that is parsable by detectEr. The tool itself is developed in Erlang, and is the product of five years of theoretical and practical development. Tutorial videos \u00b6 We have a three-part tutorial series on YouTube that gives an overview of how to use detectEr. Use these videos as a complementary learning material to this tutorial. Part 1: Diving In Part 2: Describing Program Correctness Part 3: Instrumenting the Program How it works \u00b6 There are two ingredients required for detectEr to work. The first one is a script file containing specifications of the properties one would like to monitor. Properties in detectEr are expressed in sHML\u2014a runtime monitorable syntactic subset of the more expressive modal \u03bc-calculus\u2014used to specify safety properties . detectEr compiles these specifications down to executable Erlang code that analyses program events to reach monitoring verdicts that correspond to property violations. The second ingredient detectEr requires is the program to be monitored, also called the program under scrutiny. detectEr instruments the program with the aforementioned analyser code. detectEr supports three instrumentation methods: inline, outline and offline. In inline instrumentation, detectEr statically instruments the program under scrutiny by weaving the executable analyser instructions via code injection. The ensuing runtime analysis then takes place as the weaved program components execute. Outline monitors enables detectEr to take a dynamic instrumentation approach that treats the system as a black box. It leverages the tracing infrastructure provided by the EVM to gather trace events that are reported to independent component analysers. detectEr also extends outline instrumentation to the offline case, where events read from a trace dump are replayed to emulate the interaction between concurrent system components. This tutorial overviews the inner workings of detectEr. It showcases the inline, outline, and offline monitoring functionality of the tool, demonstrating how each can be employed to monitor programs that are subject to specific deployment and runtime constraints. We highly encourage you to consult the paper that accompanies this tutorial, since it complements many of the concepts covered here. Interested readers are also referred to the list of publications that follows. Publications \u00b6 COORDINATION 2022 FORTE 2021 List of other publications to be added later :) Help us \u00b6 Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub. Our group \u00b6 detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014is a researcher with the ICE-TCS research group at Reykjav\u00edk University. He has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia. The research group consists of these members who actively contribute towards the theoretical and practical developments of detectEr: Luca Aceto Antonis Achilleos Elli Anastasiadi Duncan Paul Attard Adrian Francalanza Karoliina Lehtinen Anna Ing\u00f3lfsd\u00f3ttir Acknowledgements \u00b6 We would like to thank Matthew Alan Le Brun for his comments and feedback.","title":"Home"},{"location":"index.html#welcome-to-the-detecter-tutorial","text":"","title":"Welcome to the detectEr tutorial!"},{"location":"index.html#what-is-detecter","text":"detectEr is a runtime verification tool for asynchronous component systems that run on the Erlang Virtual Machine. It also supports monitoring systems that can execute outside of the EVM, so long as these can produce traces that are formatted in a way that is parsable by detectEr. The tool itself is developed in Erlang, and is the product of five years of theoretical and practical development.","title":"What is detectEr?"},{"location":"index.html#tutorial-videos","text":"We have a three-part tutorial series on YouTube that gives an overview of how to use detectEr. Use these videos as a complementary learning material to this tutorial. Part 1: Diving In Part 2: Describing Program Correctness Part 3: Instrumenting the Program","title":"Tutorial videos"},{"location":"index.html#how-it-works","text":"There are two ingredients required for detectEr to work. The first one is a script file containing specifications of the properties one would like to monitor. Properties in detectEr are expressed in sHML\u2014a runtime monitorable syntactic subset of the more expressive modal \u03bc-calculus\u2014used to specify safety properties . detectEr compiles these specifications down to executable Erlang code that analyses program events to reach monitoring verdicts that correspond to property violations. The second ingredient detectEr requires is the program to be monitored, also called the program under scrutiny. detectEr instruments the program with the aforementioned analyser code. detectEr supports three instrumentation methods: inline, outline and offline. In inline instrumentation, detectEr statically instruments the program under scrutiny by weaving the executable analyser instructions via code injection. The ensuing runtime analysis then takes place as the weaved program components execute. Outline monitors enables detectEr to take a dynamic instrumentation approach that treats the system as a black box. It leverages the tracing infrastructure provided by the EVM to gather trace events that are reported to independent component analysers. detectEr also extends outline instrumentation to the offline case, where events read from a trace dump are replayed to emulate the interaction between concurrent system components. This tutorial overviews the inner workings of detectEr. It showcases the inline, outline, and offline monitoring functionality of the tool, demonstrating how each can be employed to monitor programs that are subject to specific deployment and runtime constraints. We highly encourage you to consult the paper that accompanies this tutorial, since it complements many of the concepts covered here. Interested readers are also referred to the list of publications that follows.","title":"How it works"},{"location":"index.html#publications","text":"COORDINATION 2022 FORTE 2021 List of other publications to be added later :)","title":"Publications"},{"location":"index.html#help-us","text":"Please help us improve this tutorial and the tool detectEr! We would appreciate if any typos or bugs found are reported on the issues page on GitHub.","title":"Help us"},{"location":"index.html#our-group","text":"detectEr is part of the TheoFoMon and MoVeMnt projects funded by the Icelandic Research Fund . Duncan Paul Attard\u2014the principal developer of the detectEr\u2014is a researcher with the ICE-TCS research group at Reykjav\u00edk University. He has worked as a software developer in the Telecoms and Online payment industry for seven years prior to joining the academia. The research group consists of these members who actively contribute towards the theoretical and practical developments of detectEr: Luca Aceto Antonis Achilleos Elli Anastasiadi Duncan Paul Attard Adrian Francalanza Karoliina Lehtinen Anna Ing\u00f3lfsd\u00f3ttir","title":"Our group"},{"location":"index.html#acknowledgements","text":"We would like to thank Matthew Alan Le Brun for his comments and feedback.","title":"Acknowledgements"},{"location":"about.html","text":"Turba falsi florem \u00b6 Labentibus corpore nostra \u00b6 Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice? Glomerari licet io protinus colubris vires egissem \u00b6 Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Turba falsi florem"},{"location":"about.html#turba-falsi-florem","text":"","title":"Turba falsi florem"},{"location":"about.html#labentibus-corpore-nostra","text":"Lorem markdownum amplexa rector ora facies lumina sit lurida rursusque terruerat caelebs, diem. Contigit tortoque terebrata flore! daemon_soft_syn = e; overclocking = favicon; if (2 == windows(device, gifServer)) { primary *= botnetT; uncIntegrated(2 + ajax_trim_multiplatform, 664619 - internet_gigabyte_system, sampling_metal_copy); kindle = cronServerPpi; } boot_modem(1, onlineUtility, media - virtualization_trackball - macByteClip); Ab sonus: obruta nimium loco, bis nascendi nautae, solus cur ille turbamque damnatura turba madefactaque nescit Lacedaemoniumque . Ratibus iugulaberis, vetus ulla ubicumque opposui medicamina addita solacia iniusti amplexuque interque, admonitu nunc extendi sol. Nomina parentes potentum conplectitur socio, et dives adice et subit patriaeque crederet. Laesi saecula, dextrae; carpit dolos suspiria probro pendere simul hospita Gorgoneum. Accipe timeri nupsi fuit nostros quid memorem pellite metuunt: Harpalos positis plectrumque somno qui, ter falsa diversa motaque. Cum cum hic fugientibus vaccae de noluit sulphura cantu utque inmensi scopulum , vestra. Undis quotiens veteris nostro iube blanditiis nihil huc latus, igne inpune voluit, abiit, est Acmon viri. Exemplo capiebant o vocabula iusta; incubuitque interius ripas. Genitore sumptaque haud domos recens, pietas ille Zanclen secum; ferox ilice demittere cortice?","title":"Labentibus corpore nostra"},{"location":"about.html#glomerari-licet-io-protinus-colubris-vires-egissem","text":"Margine de prisca fulvis miserae in illa claroque. Apolline auras ramum fitque quoque artifices oblivia nigraque freta croceum fauce et feres: nec pyra nec vertice: vincloque. Emittere dixit. Ut populis negarunt occuluit simili ne coepit Dianae quinquennia erat scrobe speciosam. Genitor qui terra mutasse nigro ! Glaebae stetit ab a arsit ignibus digna ulcisci repressit: opem arma petis, timendi hos omni et arma puerosque. Faciem conpleat mediis, Capitolia videndo ab aurumque, clamant et mihi bubo praebetis pater viscera deus. Sed pugman, nihil laudatve cervice videri. Alas oris Thetis est superis a picto nulla gente solebat a ossibus quoque! Et suis, quae Cyllenide imoque at, quisquis nulli, repetitum. Silvas est absens negata faciat iamque putant; re et, qua dixit. Excutis adsiduae Lyncides. Suis Sithon vocat pennis lupo fallitis potuit inrorant laetoque. Hic raptores possunt fatebor cornum usa.","title":"Glomerari licet io protinus colubris vires egissem"},{"location":"erlang.html","text":"This is a test \u00b6 with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"erlang.html#this-is-a-test","text":"with calc_server : loop (_) monitor and ([_ Launcher <- _ Server , calc_server : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B ] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). with 'Elixir.Demo.CalcServer' : loop (_) monitor and ([_ Launcher <- _ Server , 'Elixir.Demo.CalcServer' : loop (_)] max ( X . and ( [_ Server ? {_, { add , A , B }}] and ( [_ Server ! { add , Res } when Res =/= A + B and is_integer ( A )] ff , [_ Server ! { add , Res } when Res =:= A + B ] X ), [_ Server ? {_, {_, _, _}}] and ( [_ Server ! {_, _}] X ), [_ Server ? {_, stop }] and ( [_ Server ! { ok , stopped }] X ) ) ) ). 1 2 3 4 5 6 7 fun ( Var ) -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end fun () -> receive Msg -> io : format ( Msg ) end end The range () function is used to generate a sequence of numbers. Ctrl + Alt + Del Ctrl + V + Tab + Enter + Cmd Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Hello Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Example Unordered List Example : * Sed sagittis eleifend rutrum * Donec vitae suscipit est * Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci Ordered List Example : 1. Sed sagittis eleifend rutrum 2. Donec vitae suscipit est 3. Nulla tempor lobortis orci Result : Sed sagittis eleifend rutrum Donec vitae suscipit est Nulla tempor lobortis orci The HTML specification is maintained by the W3C . Duncan \\[ \\operatorname{ker} f=\\{g\\in {\\color{sepia}{G}}:f(g)=e_{H}\\}{\\mbox{.}} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"This is a test"},{"location":"detecter-linear-time/getting-started.html","text":"Getting Started \u00b6 A Token Server Program in Erlang \u00b6 Let us consider a token server program consisting of a single process that handles client requests for obtaining integer identifier tokens. The server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The token server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the command 0 , signifying a new token request, and the client PID to whom the corresponding server reply should be addressed. Our token server program is implemented as the Erlang module token_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( OwnTok , NextTok ) -> receive { Clt , 0 } -> Clt ! NextTok , loop ( OwnTok , NextTok + 1 ) % Increment token. end . token_server : loop / 1 encapsulates the token server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes token_server : start / 1 for some integer argument Tok . This argument Tok is the private server token that should never be leaked. The spawned server consumes a message request from its mailbox via the receive expression on lines 5-9 , and pattern matches against the new token request operation 0 . Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , line 6 . The server uses the parameter NextTok of loop / 2 to track the current token number; OwnTok contains the private token of the token server itself. After handling a request 0 , the server executes loop / 2 to recommence the process loop and service the next client request, incrementing the next token value accordingly (line 8 ). Note that our server is designed not to terminate. Safety properties \u00b6 There are a number of properties we would like the server execution to observe. For example, the server loop does not control the initial value of Tok that an invocation to token_server : start / 1 provides. We could, therefore, require that: (P 1 ) Failure does not occur when the server is stated with its identifier token. Similarly, we would expect that (P 2 ) The server starts with its correct identifier token of 1 , and that (P 3 ) The token 1 is not leaked by the server in reply to a client request. both hold. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour program executions must comply with.","title":"Getting Started"},{"location":"detecter-linear-time/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"detecter-linear-time/getting-started.html#a-token-server-program-in-erlang","text":"Let us consider a token server program consisting of a single process that handles client requests for obtaining integer identifier tokens. The server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The token server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the command 0 , signifying a new token request, and the client PID to whom the corresponding server reply should be addressed. Our token server program is implemented as the Erlang module token_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( OwnTok , NextTok ) -> receive { Clt , 0 } -> Clt ! NextTok , loop ( OwnTok , NextTok + 1 ) % Increment token. end . token_server : loop / 1 encapsulates the token server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes token_server : start / 1 for some integer argument Tok . This argument Tok is the private server token that should never be leaked. The spawned server consumes a message request from its mailbox via the receive expression on lines 5-9 , and pattern matches against the new token request operation 0 . Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , line 6 . The server uses the parameter NextTok of loop / 2 to track the current token number; OwnTok contains the private token of the token server itself. After handling a request 0 , the server executes loop / 2 to recommence the process loop and service the next client request, incrementing the next token value accordingly (line 8 ). Note that our server is designed not to terminate.","title":"A Token Server Program in Erlang"},{"location":"detecter-linear-time/getting-started.html#safety-properties","text":"There are a number of properties we would like the server execution to observe. For example, the server loop does not control the initial value of Tok that an invocation to token_server : start / 1 provides. We could, therefore, require that: (P 1 ) Failure does not occur when the server is stated with its identifier token. Similarly, we would expect that (P 2 ) The server starts with its correct identifier token of 1 , and that (P 3 ) The token 1 is not leaked by the server in reply to a client request. both hold. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour program executions must comply with.","title":"Safety properties"},{"location":"detecter-linear-time/inline-instrumentation.html","text":"Inline Instrumentation \u00b6 Overview \u00b6 Inline instrumentation for monitoring program traces works identically to the one in the Inline Instrumentation section, where the exact sequence of steps may be followed. The only difference is that now, instead of instrumenting the target program using the weaver module, lin_weaver should be used instead. This module offers the same source code-level weaving functionality, and supports the same configuration options. Refer to Inline instrumentation in action for more details. Instrumentation Support At present, the linear-time version of detectEr only supports inline instrumentation; outlining is currently under development, and will be added in the near future. The token server program \u00b6 Let us run the token server program with no instrumentation applied, to familiarise ourselves with its basic operation. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. Launch the Erlang shell erl . We add the detectEr binaries and the ones we have just compiled to the shell code path via -pa . [duncan@local]:/detecter/examples/erlang$ erl -pa ../../detecter/ebin ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> The token server is started by invoking token_server : start / 1 . If you recall from the section Getting Started , start / 1 accepts a single argument Tok that it uses to track the next identifier token. Function start / 1 spawns the server process and returns its PID . We need to hold on to this PID in order to use it to communicate with our server. To do this, we store the PID in the variable Pid . 1> Pid = token_server : start ( 0 ). <0.86.0> We can check that the server process has actually started using the is_process_alive/1 BIF . 2> is_process_alive ( Pid ). true The server is now ready to handle client requests. Messages in Erlang are submitted using the send operator, ! , that takes the PID of the recipient process and the message to send as arguments. The data in the request message we send must coincide with the clause that the server is able to pattern match in its receive expression. When this is not the case, the message is not processed, and left queued in the token server mailbox. Try requesting a new identifier token. 3> Pid ! { self (), 0 }. (1) Serving token request with 1. {<0.84.0>,0} Send expressions in Erlang evaluate to the message sent, which is why the shell prints the output { < 0 . 84 . 0 > , 0 } . Note that this is not the server reply. To obtain the server reply from the mailbox of the shell, we use another BIF , flush / 0 , that empties the mailbox contents on the shell. 4> flush (). Shell got {ok,1} ok To interrupt the Erlang shell, press Ctrl + C followed by A . 5> BREAK: (a)bort (A)bort with dump (c)ontinue (p)roc info (i)nfo (l)oaded (v)ersion (k)ill (D)b-tables (d)istribution We note that at this point, the server PID value < 0 . 84 . 0 > is still instantiated in the variable Pid, which is now stale. Sending a message to a non-existing PID via ! is silently ignored without raising any errors. Inline instrumentation in action \u00b6 Since in the previous section we executed make that cleans the ebin directory, we have to once more synthesise our analyser. 6> maxhml_eval : compile ( \"props/prop_no_leak.hml\" , [{ outdir , \"ebin\" }]). ok Now we can instrument the server we want analysed. detectEr provides the lin_weaver module that offers two functions, weave_file / 3 that weaves a single file, and weave / 3 that weaves an entire directory of files. We will use weave / 3 to weave the directory where our token server is located. The two variants of weave accept three arguments: the file where the Erlang source file to be weaved resides (or directory of files, in case of weave / 3 ), the function mfa_spec / 1 of the analyser we want weaved, and, an option list. The options supported by weave_file / 3 and weaver / 3 are as follows: Option Description outdir Directory where the generated weaved files should be written. If left unspecified, defaults to the current directory . . i Directory containing include files that the source files in the source directory depend on. filter Filter function that suppresses events. If left unspecified, defaults to \u2018allows any\u2019. erl Instructs the compiler to output the generated files as Erlang source code rather than beam . If left unspecified, defaults to beam . For this demo, we use our token server to detect property violations. Weave the src/demo directory by executing: 7> lin_weaver : weave ( \"src/demo\" , fun prop_no_leak : mfa_spec / 1 , [{ outdir , \"ebin\" }]). [{ok,calc_client,[]}, {ok,calc_server,[]}, {ok,token_server,[]}] {ok,calc_server_bug,[]}, {ok,hello,[]} The weaved files will be automatically loaded for you in the shell. Next, launch the server. We will use the same variable Pid to keep hold of the PID returned by token_server:start/1 . Since Erlang does not allow variables to be assigned more than once, we have to free the variable Pid before reusing it. We do this using the f/1 BIF . 8> f ( Pid ). ok 9> Pid = token_server : start ( 1 ). <0.88.0> As soon as the token server process starts, the analyser immediately enters into action and analyses the first process event init . Now, let us request a token. 10> Pid ! { self (), 0 }}. {<0.84.0>,1} :: Violation: Reached after analyzing event {send,<0.88.0>,<0.84.0>,1}. This leads to a rejection verdict, no , that corresponds to a violation of our property P 3 . Try requesting a second token. 11> Pid ! { self (), 0 }}. {<0.84.0>,0} :: Violation: Reached after analyzing event {recv,<0.88.0>,{<0.84.0>,0}}. :: Violation: Reached after analyzing event {send,<0.88.0>,<0.84.0>,2}. Irrevocable verdicts \u00b6 You might have noticed that the recv and send events exhibited by the server process as it terminated (step 4 above) are also analysed by our analyser. Both of these analyses yield the same rejection verdict of no . Why does this happen? In the section Is one execution trace enough? we explained that analysers yield irrevocable verdicts ( i.e. , ones that cannot be retracted). This is one such instance, where the verdict no is flagged, and the analyser will persist its decision, regardless of the events it analyses going forward. Correcting the server implementation \u00b6 Let us once again look at the server implementation. 1 2 3 4 5 6 7 8 9 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( OwnTok , NextTok ) -> receive { Clt , 0 } -> Clt ! NextTok , loop ( OwnTok , NextTok + 1 ) % Increment token. end . Now we know that our implementation contains a bug that is exhibited as soon as the token server issues its first token. A close at the server that the main server loop token_server : loop / 2 is launched with the value of Tok on line 2 . This same value is then returned in reply to a client request. There are two possible solutions to this bug. The first solution is to start the server loop, token_server : loop / 2 , with a different next token offset that will surely not be returned by the server. One good candidate (amongst infinitely many others) is to use the arguments ( Tok , Tok + 1 ) on line 2 . The second solution is to change the code on line 7 to Clt ! NextTok + 1 . Try running the correct version of the server, following steps 2-4 above. Launch the instrumented server. 12> f ( Pid ). Pid = token_server:start(1). <0.90.0> Perform an token request. 13> Pid ! { self (), 0 }. {<0.84.0>,0} In this case where the request is correctly executed by the server, the analyser unfolds the recursion via the variable X , and resumes its analysis. Try requesting a second token. 14> Pid ! { self (), 0 }. {<0.84.0>,0} The analyser reaches the inconclusive verdict end since given the event { trace , < 0 . 146 . 0 > , 'receive' ,{ < 0 . 84 . 0 > ,{ mul , 10 , 97 }}} , it cannot determine whether these will eventually lead to a violation. Furthermore, now that the analyser has reached this point of inconclusiveness, it cannot backtrack, and will always yield the verdict end for every subsequent event it analyses. This is another instance of verdict irrevocability. The runtime analysis does not detect any violations of the property.","title":"Inline Instrumentation"},{"location":"detecter-linear-time/inline-instrumentation.html#inline-instrumentation","text":"","title":"Inline Instrumentation"},{"location":"detecter-linear-time/inline-instrumentation.html#overview","text":"Inline instrumentation for monitoring program traces works identically to the one in the Inline Instrumentation section, where the exact sequence of steps may be followed. The only difference is that now, instead of instrumenting the target program using the weaver module, lin_weaver should be used instead. This module offers the same source code-level weaving functionality, and supports the same configuration options. Refer to Inline instrumentation in action for more details. Instrumentation Support At present, the linear-time version of detectEr only supports inline instrumentation; outlining is currently under development, and will be added in the near future.","title":"Overview"},{"location":"detecter-linear-time/inline-instrumentation.html#the-token-server-program","text":"Let us run the token server program with no instrumentation applied, to familiarise ourselves with its basic operation. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. Launch the Erlang shell erl . We add the detectEr binaries and the ones we have just compiled to the shell code path via -pa . [duncan@local]:/detecter/examples/erlang$ erl -pa ../../detecter/ebin ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> The token server is started by invoking token_server : start / 1 . If you recall from the section Getting Started , start / 1 accepts a single argument Tok that it uses to track the next identifier token. Function start / 1 spawns the server process and returns its PID . We need to hold on to this PID in order to use it to communicate with our server. To do this, we store the PID in the variable Pid . 1> Pid = token_server : start ( 0 ). <0.86.0> We can check that the server process has actually started using the is_process_alive/1 BIF . 2> is_process_alive ( Pid ). true The server is now ready to handle client requests. Messages in Erlang are submitted using the send operator, ! , that takes the PID of the recipient process and the message to send as arguments. The data in the request message we send must coincide with the clause that the server is able to pattern match in its receive expression. When this is not the case, the message is not processed, and left queued in the token server mailbox. Try requesting a new identifier token. 3> Pid ! { self (), 0 }. (1) Serving token request with 1. {<0.84.0>,0} Send expressions in Erlang evaluate to the message sent, which is why the shell prints the output { < 0 . 84 . 0 > , 0 } . Note that this is not the server reply. To obtain the server reply from the mailbox of the shell, we use another BIF , flush / 0 , that empties the mailbox contents on the shell. 4> flush (). Shell got {ok,1} ok To interrupt the Erlang shell, press Ctrl + C followed by A . 5> BREAK: (a)bort (A)bort with dump (c)ontinue (p)roc info (i)nfo (l)oaded (v)ersion (k)ill (D)b-tables (d)istribution We note that at this point, the server PID value < 0 . 84 . 0 > is still instantiated in the variable Pid, which is now stale. Sending a message to a non-existing PID via ! is silently ignored without raising any errors.","title":"The token server program"},{"location":"detecter-linear-time/inline-instrumentation.html#inline-instrumentation-in-action","text":"Since in the previous section we executed make that cleans the ebin directory, we have to once more synthesise our analyser. 6> maxhml_eval : compile ( \"props/prop_no_leak.hml\" , [{ outdir , \"ebin\" }]). ok Now we can instrument the server we want analysed. detectEr provides the lin_weaver module that offers two functions, weave_file / 3 that weaves a single file, and weave / 3 that weaves an entire directory of files. We will use weave / 3 to weave the directory where our token server is located. The two variants of weave accept three arguments: the file where the Erlang source file to be weaved resides (or directory of files, in case of weave / 3 ), the function mfa_spec / 1 of the analyser we want weaved, and, an option list. The options supported by weave_file / 3 and weaver / 3 are as follows: Option Description outdir Directory where the generated weaved files should be written. If left unspecified, defaults to the current directory . . i Directory containing include files that the source files in the source directory depend on. filter Filter function that suppresses events. If left unspecified, defaults to \u2018allows any\u2019. erl Instructs the compiler to output the generated files as Erlang source code rather than beam . If left unspecified, defaults to beam . For this demo, we use our token server to detect property violations. Weave the src/demo directory by executing: 7> lin_weaver : weave ( \"src/demo\" , fun prop_no_leak : mfa_spec / 1 , [{ outdir , \"ebin\" }]). [{ok,calc_client,[]}, {ok,calc_server,[]}, {ok,token_server,[]}] {ok,calc_server_bug,[]}, {ok,hello,[]} The weaved files will be automatically loaded for you in the shell. Next, launch the server. We will use the same variable Pid to keep hold of the PID returned by token_server:start/1 . Since Erlang does not allow variables to be assigned more than once, we have to free the variable Pid before reusing it. We do this using the f/1 BIF . 8> f ( Pid ). ok 9> Pid = token_server : start ( 1 ). <0.88.0> As soon as the token server process starts, the analyser immediately enters into action and analyses the first process event init . Now, let us request a token. 10> Pid ! { self (), 0 }}. {<0.84.0>,1} :: Violation: Reached after analyzing event {send,<0.88.0>,<0.84.0>,1}. This leads to a rejection verdict, no , that corresponds to a violation of our property P 3 . Try requesting a second token. 11> Pid ! { self (), 0 }}. {<0.84.0>,0} :: Violation: Reached after analyzing event {recv,<0.88.0>,{<0.84.0>,0}}. :: Violation: Reached after analyzing event {send,<0.88.0>,<0.84.0>,2}.","title":"Inline instrumentation in action"},{"location":"detecter-linear-time/inline-instrumentation.html#irrevocable-verdicts","text":"You might have noticed that the recv and send events exhibited by the server process as it terminated (step 4 above) are also analysed by our analyser. Both of these analyses yield the same rejection verdict of no . Why does this happen? In the section Is one execution trace enough? we explained that analysers yield irrevocable verdicts ( i.e. , ones that cannot be retracted). This is one such instance, where the verdict no is flagged, and the analyser will persist its decision, regardless of the events it analyses going forward.","title":"Irrevocable verdicts"},{"location":"detecter-linear-time/inline-instrumentation.html#correcting-the-server-implementation","text":"Let us once again look at the server implementation. 1 2 3 4 5 6 7 8 9 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( OwnTok , NextTok ) -> receive { Clt , 0 } -> Clt ! NextTok , loop ( OwnTok , NextTok + 1 ) % Increment token. end . Now we know that our implementation contains a bug that is exhibited as soon as the token server issues its first token. A close at the server that the main server loop token_server : loop / 2 is launched with the value of Tok on line 2 . This same value is then returned in reply to a client request. There are two possible solutions to this bug. The first solution is to start the server loop, token_server : loop / 2 , with a different next token offset that will surely not be returned by the server. One good candidate (amongst infinitely many others) is to use the arguments ( Tok , Tok + 1 ) on line 2 . The second solution is to change the code on line 7 to Clt ! NextTok + 1 . Try running the correct version of the server, following steps 2-4 above. Launch the instrumented server. 12> f ( Pid ). Pid = token_server:start(1). <0.90.0> Perform an token request. 13> Pid ! { self (), 0 }. {<0.84.0>,0} In this case where the request is correctly executed by the server, the analyser unfolds the recursion via the variable X , and resumes its analysis. Try requesting a second token. 14> Pid ! { self (), 0 }. {<0.84.0>,0} The analyser reaches the inconclusive verdict end since given the event { trace , < 0 . 146 . 0 > , 'receive' ,{ < 0 . 84 . 0 > ,{ mul , 10 , 97 }}} , it cannot determine whether these will eventually lead to a violation. Furthermore, now that the analyser has reached this point of inconclusiveness, it cannot backtrack, and will always yield the verdict end for every subsequent event it analyses. This is another instance of verdict irrevocability. The runtime analysis does not detect any violations of the property.","title":"Correcting the server implementation"},{"location":"detecter-linear-time/setting-up-detecter.html","text":"Setting up detectEr Linear Time \u00b6 Downloading detectEr Linear Time \u00b6 The full detectEr project can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Token server implementation in Erlang src Erlang module sources props maxHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license Compiling detectEr \u00b6 For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr With detectEr compiled, let us move on to our first \u2018hello world\u2019 example!","title":"Setting up detectEr Linear Time"},{"location":"detecter-linear-time/setting-up-detecter.html#setting-up-detecter-linear-time","text":"","title":"Setting up detectEr Linear Time"},{"location":"detecter-linear-time/setting-up-detecter.html#downloading-detecter-linear-time","text":"The full detectEr project can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Token server implementation in Erlang src Erlang module sources props maxHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license","title":"Downloading detectEr Linear Time"},{"location":"detecter-linear-time/setting-up-detecter.html#compiling-detecter","text":"For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr With detectEr compiled, let us move on to our first \u2018hello world\u2019 example!","title":"Compiling detectEr"},{"location":"detecter-linear-time/synthesising-analysers.html","text":"Synthesising Analysers \u00b6 Trace events, in practice \u00b6 When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework. To disentangle the specification and analysis concepts, detectEr employs the intermediate representation seen earlier , consisting of the program events, fork , init , exit , send and recv . These intermediate events are internally translated to the ones that the native Erlang tracing infrastructure uses. We adopt this approach since it simplifies the implementation of analysers. From specification to analyser \u00b6 To demonstrate how you can use detectEr to synthesise analysers, we use the formalisation of property P 3 as a vehicle. detectEr Linear Time provides the maxhml_eval : compile / 2 function that compiles maxHML specifications to executable Erlang code. The compile function accepts two arguments, the path that points to the maxHML script file, and a list of options that control how the resulting analyser is generated. maxHML script files are plain text formatted files with a .hml extension, and must at least contain one specification. Multiple specifications are separated with comma, and every file must be terminated with a full-stop. The configuration options that maxhml_eval : compile / 2 are as follows. Option Description outdir Directory where the synthesised analyser file should be written. If left unspecified, defaults to the current directory . . erl Instructs compile function to output the synthesised analyser as Erlang source code rather than in beam format. If left unspecified, defaults to beam . Analysers are synthesised from the Erlang shell, which needs to have the detectEr binaries loaded in its code path. This is done by launching the shell with the -pa flag. For this example, we change the directory to examples/erlang and launch the Erlang shell, of course assuming that the detectEr source files have already been compiled. Refer to the section Setting up detectEr Linear Time if you need to do this. [duncan@local]:$ cd examples/erlang [duncan@local]:$ erl -pa ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> With the Erlang shell loaded, compile the prop_no_leak.hml . 1> maxhml_eval : compile ( \"props/prop_no_leak.hml\" , [{ outdir , \"ebin\" }, erl ]). ok We have specified the erl option to generate the analyser source code in order to overview the internal workings of analysers. You may skip this section if you want just learn how to to use the tool. So the first thing that we should note is that the analyser is one higher-order function returns other functions or atoms in turn. The init , send , recv event patterns in the specification are translated by maxhml_eval : compile / 2 to the event format that the EVM uses for tracing. These event mappings are tabled below. Program event Pattern EVM trace event translation fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawn , P\u2082 , { Mod , Fun , Args }} init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawned , P\u2082 , { Mod , Fun , Args }} exit P\u2081 ** Reason { trace , P\u2081 , exit , Reason } send P\u2081 : P\u2082 ! Msg { trace , P\u2081 , send , Msg , P\u2082 } recv P\u2082 ? Msg { trace , P\u2081 , 'receive' , Msg } The entry point to analysers is the hardcoded function mfa_spec / 1 that accepts as an argument the function that we designated with the keyword with , line 5 . We revisit mfa_spec / 1 when we discuss the instrumentation. In the specific case of our token server example, the targeted function on line 5 is loop in the token_server module. Our examples packaged with the detectEr distribution include a second implementation of a buggy token server which we will use to show how analysers flag rejection verdicts. prop_no_leak.hml specifies the same formalisation of P 3 for this buggy version. We will use this buggy version of the token server to show how a rejection verdict is reached when the incorrect behaviour in the program trace is detected. Executable analysers \u00b6 We can go ahead and recompile prop_no_leak.hml script, this time removing the erl option. Of course, the resulting analyser binary must be included in the code path of the program we are running, together with the detectEr binaries. 2> maxhml_eval : compile ( \"props/prop_no_leak.hml\" , [{ outdir , \"ebin\" }]). ok Now we look at how we instrument the system with monitors.","title":"Synthesising Analysers"},{"location":"detecter-linear-time/synthesising-analysers.html#synthesising-analysers","text":"","title":"Synthesising Analysers"},{"location":"detecter-linear-time/synthesising-analysers.html#trace-events-in-practice","text":"When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework. To disentangle the specification and analysis concepts, detectEr employs the intermediate representation seen earlier , consisting of the program events, fork , init , exit , send and recv . These intermediate events are internally translated to the ones that the native Erlang tracing infrastructure uses. We adopt this approach since it simplifies the implementation of analysers.","title":"Trace events, in practice"},{"location":"detecter-linear-time/synthesising-analysers.html#from-specification-to-analyser","text":"To demonstrate how you can use detectEr to synthesise analysers, we use the formalisation of property P 3 as a vehicle. detectEr Linear Time provides the maxhml_eval : compile / 2 function that compiles maxHML specifications to executable Erlang code. The compile function accepts two arguments, the path that points to the maxHML script file, and a list of options that control how the resulting analyser is generated. maxHML script files are plain text formatted files with a .hml extension, and must at least contain one specification. Multiple specifications are separated with comma, and every file must be terminated with a full-stop. The configuration options that maxhml_eval : compile / 2 are as follows. Option Description outdir Directory where the synthesised analyser file should be written. If left unspecified, defaults to the current directory . . erl Instructs compile function to output the synthesised analyser as Erlang source code rather than in beam format. If left unspecified, defaults to beam . Analysers are synthesised from the Erlang shell, which needs to have the detectEr binaries loaded in its code path. This is done by launching the shell with the -pa flag. For this example, we change the directory to examples/erlang and launch the Erlang shell, of course assuming that the detectEr source files have already been compiled. Refer to the section Setting up detectEr Linear Time if you need to do this. [duncan@local]:$ cd examples/erlang [duncan@local]:$ erl -pa ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> With the Erlang shell loaded, compile the prop_no_leak.hml . 1> maxhml_eval : compile ( \"props/prop_no_leak.hml\" , [{ outdir , \"ebin\" }, erl ]). ok We have specified the erl option to generate the analyser source code in order to overview the internal workings of analysers. You may skip this section if you want just learn how to to use the tool. So the first thing that we should note is that the analyser is one higher-order function returns other functions or atoms in turn. The init , send , recv event patterns in the specification are translated by maxhml_eval : compile / 2 to the event format that the EVM uses for tracing. These event mappings are tabled below. Program event Pattern EVM trace event translation fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawn , P\u2082 , { Mod , Fun , Args }} init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawned , P\u2082 , { Mod , Fun , Args }} exit P\u2081 ** Reason { trace , P\u2081 , exit , Reason } send P\u2081 : P\u2082 ! Msg { trace , P\u2081 , send , Msg , P\u2082 } recv P\u2082 ? Msg { trace , P\u2081 , 'receive' , Msg } The entry point to analysers is the hardcoded function mfa_spec / 1 that accepts as an argument the function that we designated with the keyword with , line 5 . We revisit mfa_spec / 1 when we discuss the instrumentation. In the specific case of our token server example, the targeted function on line 5 is loop in the token_server module. Our examples packaged with the detectEr distribution include a second implementation of a buggy token server which we will use to show how analysers flag rejection verdicts. prop_no_leak.hml specifies the same formalisation of P 3 for this buggy version. We will use this buggy version of the token server to show how a rejection verdict is reached when the incorrect behaviour in the program trace is detected.","title":"From specification to analyser"},{"location":"detecter-linear-time/synthesising-analysers.html#executable-analysers","text":"We can go ahead and recompile prop_no_leak.hml script, this time removing the erl option. Of course, the resulting analyser binary must be included in the code path of the program we are running, together with the detectEr binaries. 2> maxhml_eval : compile ( \"props/prop_no_leak.hml\" , [{ outdir , \"ebin\" }]). ok Now we look at how we instrument the system with monitors.","title":"Executable analysers"},{"location":"detecter-linear-time/the-specification-logic.html","text":"The Specification Logic maxHML \u00b6 Overview \u00b6 maxHML enables us to express properties on the executions of programs. Like sHML , maxHML is a another syntactic subset of the more expressive Hennessy-Milner Logic with recursion. It is used to express safety properties, but by contrast to the sHML fragment of The Specification Logic sHML , maxHML is interpreted over executions (called traces ), rather than process execution graphs. maxHML formulae are generated from the following grammar: \u03c6 , \u03c8 \u2208 maxHML :: = ff | tt (1) | < \u03b1 > \u03c6 (2) | [ \u03b1 ] \u03c6 (3) | \u03c6 or \u03c8 (4) | \u03c6 and \u03c8 (5) | X (6) | max ( X . \u03c6 ) (7) Formulae ff and tt denote falsity and truth respectively, < \u03b1 > \u03c6 is the existential modal operator guarding the continuation formula \u03c6 (also called a possibility ), [ \u03b1 ] \u03c6 , the dual of <\u03b1>\u03c6 , is the universal modal operator guarding the continuation formula \u03c6 (also called a necessity ), \u03c6 or \u03c8 is a disjunction , \u03c6 and \u03c8 is a conjunction , X is a logical variable , and, max ( X . \u03c6 ) is the greatest fixed point construct that specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula \u03c6 . To handle reasoning over program event data, the modal operator is equipped with symbolic actions \u03b1 of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula \u03c6 . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. We say that a trace satisfies the formula < P when C > \u03c6 when it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour also satisfies \u03c6 . Dually, a trace satisfies [ P when C ] \u03c6 whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies \u03c6 . When the constraint is true , the expression when C may be omitted for readability. Pattern and constraint expressions \u00b6 detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P\u2081 * Reason P\u2081 PID of the terminated process Reason Termination reason send P\u2081 : P\u2082 ! Msg P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv P\u2082 ? Msg P\u2082 PID of the recipient process Msg Message payload The variables P\u2081 and P\u2082 in event patterns must be a port ID or PID , whereas Reason and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse . A simple example \u00b6 Let us try to specify a safety requirement on the traces of our token server program . The maxHML formula with symbolic action Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 describes the property requiring that \u201cthe server does not start with an identifier token other than 1 \u201d. [ Prnt \u2190 Srv , token_server : loop ([ Tok ]) when Tok =/= 1 ] ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] \u03c6 , the rest of the trace must then satisfy the continuation formula \u03c6 . However, no trace continuation can satisfy the formula ff ! This means that the [ Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 ] ff can only be satisfied when our trace does not exhibit the event described by the symbolic action Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 . Suppose our server with PID < 0 . 10 . 0 > exhibits the init event < 0 . 16 . 0 > \u2190 < 0 . 10 . 0 > , token_server : loop ([ - 1 , 0 ]) when launched by a parent process with PID < 0 . 16 . 0 > . It matches pattern Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 , instantiating the variables Srv = < 0 . 10 . 0 > , Prnt = < 0 . 16 . 0 > , and OwnTok = - 1 . The constraint when OwnTok =/= 1 is also satisfied, leading to a violation, i.e. , ff . For a different init event < 0 . 16 . 0 > \u2190 < 0 . 10 . 0 > , token_server : loop ([ 1 , 0 ]) , the symbolic action in the modality [ Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 ] is not satisfied, and consequently, [ Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 ] ff is satisfied. Analogously, the init event <0.16.0> \u2190 <0.10.0>, calc_server:loop() satisfies the formula since the pattern Prnt \u2190 Srv , token_server : loop ([ Tok ]) fails to match the event shape. Cheat sheet The formula < \u03b1 > tt means that it is possible for the trace to exhibit the symbolic action \u03b1 . Dually, [ \u03b1 ] ff states that the trace must not exhibit the symbolic action \u03b1 . You should try expressing the safety properties P 1 , P 2 , and P 3 stated informally in the Getting Started section in terms of maxHML . Keep in mind that now, our formal model is the set of traces generated by the program , rather than the program transition graph itself. We next learn how runtime monitors can be synthesised from maxHML .","title":"The Specification Logic"},{"location":"detecter-linear-time/the-specification-logic.html#the-specification-logic-maxhml","text":"","title":"The Specification Logic maxHML"},{"location":"detecter-linear-time/the-specification-logic.html#overview","text":"maxHML enables us to express properties on the executions of programs. Like sHML , maxHML is a another syntactic subset of the more expressive Hennessy-Milner Logic with recursion. It is used to express safety properties, but by contrast to the sHML fragment of The Specification Logic sHML , maxHML is interpreted over executions (called traces ), rather than process execution graphs. maxHML formulae are generated from the following grammar: \u03c6 , \u03c8 \u2208 maxHML :: = ff | tt (1) | < \u03b1 > \u03c6 (2) | [ \u03b1 ] \u03c6 (3) | \u03c6 or \u03c8 (4) | \u03c6 and \u03c8 (5) | X (6) | max ( X . \u03c6 ) (7) Formulae ff and tt denote falsity and truth respectively, < \u03b1 > \u03c6 is the existential modal operator guarding the continuation formula \u03c6 (also called a possibility ), [ \u03b1 ] \u03c6 , the dual of <\u03b1>\u03c6 , is the universal modal operator guarding the continuation formula \u03c6 (also called a necessity ), \u03c6 or \u03c8 is a disjunction , \u03c6 and \u03c8 is a conjunction , X is a logical variable , and, max ( X . \u03c6 ) is the greatest fixed point construct that specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula \u03c6 . To handle reasoning over program event data, the modal operator is equipped with symbolic actions \u03b1 of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula \u03c6 . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. We say that a trace satisfies the formula < P when C > \u03c6 when it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour also satisfies \u03c6 . Dually, a trace satisfies [ P when C ] \u03c6 whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies \u03c6 . When the constraint is true , the expression when C may be omitted for readability.","title":"Overview"},{"location":"detecter-linear-time/the-specification-logic.html#pattern-and-constraint-expressions","text":"detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P\u2081 * Reason P\u2081 PID of the terminated process Reason Termination reason send P\u2081 : P\u2082 ! Msg P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv P\u2082 ? Msg P\u2082 PID of the recipient process Msg Message payload The variables P\u2081 and P\u2082 in event patterns must be a port ID or PID , whereas Reason and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse .","title":"Pattern and constraint expressions"},{"location":"detecter-linear-time/the-specification-logic.html#a-simple-example","text":"Let us try to specify a safety requirement on the traces of our token server program . The maxHML formula with symbolic action Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 describes the property requiring that \u201cthe server does not start with an identifier token other than 1 \u201d. [ Prnt \u2190 Srv , token_server : loop ([ Tok ]) when Tok =/= 1 ] ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] \u03c6 , the rest of the trace must then satisfy the continuation formula \u03c6 . However, no trace continuation can satisfy the formula ff ! This means that the [ Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 ] ff can only be satisfied when our trace does not exhibit the event described by the symbolic action Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 . Suppose our server with PID < 0 . 10 . 0 > exhibits the init event < 0 . 16 . 0 > \u2190 < 0 . 10 . 0 > , token_server : loop ([ - 1 , 0 ]) when launched by a parent process with PID < 0 . 16 . 0 > . It matches pattern Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 , instantiating the variables Srv = < 0 . 10 . 0 > , Prnt = < 0 . 16 . 0 > , and OwnTok = - 1 . The constraint when OwnTok =/= 1 is also satisfied, leading to a violation, i.e. , ff . For a different init event < 0 . 16 . 0 > \u2190 < 0 . 10 . 0 > , token_server : loop ([ 1 , 0 ]) , the symbolic action in the modality [ Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 ] is not satisfied, and consequently, [ Prnt \u2190 Srv , token_server : loop ([ OwnTok , _]) when OwnTok =/= 1 ] ff is satisfied. Analogously, the init event <0.16.0> \u2190 <0.10.0>, calc_server:loop() satisfies the formula since the pattern Prnt \u2190 Srv , token_server : loop ([ Tok ]) fails to match the event shape. Cheat sheet The formula < \u03b1 > tt means that it is possible for the trace to exhibit the symbolic action \u03b1 . Dually, [ \u03b1 ] ff states that the trace must not exhibit the symbolic action \u03b1 . You should try expressing the safety properties P 1 , P 2 , and P 3 stated informally in the Getting Started section in terms of maxHML . Keep in mind that now, our formal model is the set of traces generated by the program , rather than the program transition graph itself. We next learn how runtime monitors can be synthesised from maxHML .","title":"A simple example"},{"location":"detecter-linear-time/verdict-explainability.html","text":"Macro Rendering Error \u00b6 TemplateSyntaxError : unexpected \u2018<\u2019 Traceback (most recent call last): File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/mkdocs_macros/plugin.py\", line 441, in render md_template = self.env.from_string(markdown) File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/jinja2/environment.py\", line 1092, in from_string return cls.from_code(self, self.compile(source), gs, None) File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/jinja2/environment.py\", line 757, in compile self.handle_exception(source=source_hint) File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/jinja2/environment.py\", line 925, in handle_exception raise rewrite_traceback_stack(source=source) File \"<unknown>\", line 318, in template jinja2.exceptions.TemplateSyntaxError: unexpected '<'","title":"Verdict Explainability"},{"location":"detecter-linear-time/verdict-explainability.html#macro-rendering-error","text":"TemplateSyntaxError : unexpected \u2018<\u2019 Traceback (most recent call last): File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/mkdocs_macros/plugin.py\", line 441, in render md_template = self.env.from_string(markdown) File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/jinja2/environment.py\", line 1092, in from_string return cls.from_code(self, self.compile(source), gs, None) File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/jinja2/environment.py\", line 757, in compile self.handle_exception(source=source_hint) File \"/Users/duncan/Dropbox/PhD/Development/detecter/tutorial/venv/lib/python3.9/site-packages/jinja2/environment.py\", line 925, in handle_exception raise rewrite_traceback_stack(source=source) File \"<unknown>\", line 318, in template jinja2.exceptions.TemplateSyntaxError: unexpected '<'","title":"Macro Rendering Error"},{"location":"getting-started/preparation.html","text":"Preparation \u00b6 Prerequisites \u00b6 This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation Installing Erlang \u00b6 Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version . Installing Elixir \u00b6 Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version . Installing Python \u00b6 We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version . Installing the virtual environment management tool \u00b6 Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv . Configuring Visual Studio Code \u00b6 Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems. Adding extensions \u00b6 To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang Elixir Python Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0 Now that your system is set up, we can proceed to download and compile detectEr.","title":"Preparation"},{"location":"getting-started/preparation.html#preparation","text":"","title":"Preparation"},{"location":"getting-started/preparation.html#prerequisites","text":"This tutorial assumes that users are running Ubuntu/Debian, macOS or Windows 10. Windows 10 users may either install the Windows Subsystem for Linux and follow the instructions given below for Ubuntu/Debian , or alternatively, configure Chocolatey and install the software packages mentioned via choco install . However, our instructions will not detail how detectEr is installed and used on Windows systems. Please install the software package management system available for your particular operating system before proceeding with the rest of the guide. Operating System Package Manager Installation Ubuntu/Debian APT Not required, comes pre-bundled macOS Homebrew Follow the Homebrew guide for installation Windows 10 Chocolatey Follow the Chocolatey guide for installation","title":"Prerequisites"},{"location":"getting-started/preparation.html#installing-erlang","text":"Erlang can be installed on multiple platforms by compiling it from source or downloading one of the pre-compiled distributions hosted on erlang-solutions.com . We however follow the simpler route and install Erlang using the package managers mentioned above. Ubuntu/Debian On Ubuntu and Debian, Erlang can be installed using APT . Add the Erlang Solutions repository: wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb sudo dpkg -i erlang-solutions_2.0_all.deb Refresh the package manager repository cache: sudo apt update . Install the entire Erlang/ OTP suite only: sudo apt install erlang . macOS macOS users can install the entire Erlang/ OTP suite using Homebrew by running: brew install erlang . Windows 10 Windows 10 users not using WSL can install the entire Erlang/ OTP suite using Chocolatey by running: choco install erlang . Others Refer to the Erlang Solutions guide for installing Erlang/ OTP on other operating systems. Quick check Confirm that Erlang/ OTP distribution has been successfully installed and that the system PATH variable is properly configured by typing erl --version .","title":"Installing Erlang"},{"location":"getting-started/preparation.html#installing-elixir","text":"Elixir runs on the Erlang virtual machine and uses the same OTP libraries. We already installed the Erlang ecosystem, and need only install the Elixir language libraries. Ubuntu/Debian On Ubuntu and Debian, Elixir can be installed via APT using: sudo apt-get install elixir . macOS macOS users can install Elixir using Homebrew by running: brew install elixir . Windows 10 Windows 10 users not using WSL can install Elixir using Chocolatey by running: choco install elixir . Others Refer to the Elixir Lang guide for installing Elixir on other operating systems. Quick check Confirm that Elixir has been successfully installed and that the system PATH variable is properly configured by typing elixir --version .","title":"Installing Elixir"},{"location":"getting-started/preparation.html#installing-python","text":"We also make use of Python 3, that can be installed as explained below. Ubuntu/Debian Most distributions of Ubuntu and Debian come with Python pre-installed. Check the version of Python available on your operating system by executing python --version . If the reported version is older than 3.7.x or Python is not installed, follow these steps. Refresh the package manager repository cache (if not already done): sudo apt update . Install Python 3: sudo apt install python3.9 . Install the Python package manager PIP : sudo apt install python3-pip . Also install the core development support tools: sudo apt install -y build-essential libssl-dev libffi-dev python3-dev . macOS macOS comes pre-installed with Python 2.7, which is not the version we use in this tutorial. Install Python 3 via Homebrew by typing: brew install python3 . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Windows 10 Windows 10 users not using WSL can install Python 3 via Chocolatey by typing: choco install python . The Python package manager PIP for Python 3 is bundled in the recent versions of Python. Others Refer to the Real Python guide for installing Python 3 on other operating systems. Quick check Confirm that Python 3 has been successfully installed and that the system PATH variable is properly configured by typing python3 --version . Also check that PIP for Python 3 has been installed, pip3 --version .","title":"Installing Python"},{"location":"getting-started/preparation.html#installing-the-virtual-environment-management-tool","text":"Virtualenv is a tool used to create isolated Python environments. The environment it creates has its own installation directory, and does not share libraries with other Virtualenv environments. Virtualenv can be installed via PIP : pip3 install virtualenv .","title":"Installing the virtual environment management tool"},{"location":"getting-started/preparation.html#configuring-visual-studio-code","text":"Any plain text editor can be used, but for this tutorial we opt for Visual Studio Code that can be downloaded from https://code.visualstudio.com . It can also be installed using the respective operating system package manager. Ubuntu/Debian On Ubuntu and Debian, VS Code can be installed using APT . Install APT transport for downloading packages via HTTPS: sudo apt install apt-transport-https to check Import the Microsoft GPG key: wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add - Add the VS Code repository by typing: sudo add-apt-repository \"deb [arch=amd64] https://packages.microsoft.com/repos/code stable main\" Refresh the package manager repository cache: sudo apt update . Install VS Code: sudo apt install code . macOS macOS users can install VS Code using Homebrew by running: brew install --cask visual-studio-code . Windows 10 Windows 10 users not using WSL can install VS Code using Chocolatey by running: choco install vscode . Others Refer to the Visual Studio Code guide for installing it on other operating systems.","title":"Configuring Visual Studio Code"},{"location":"getting-started/preparation.html#adding-extensions","text":"To enable syntax highlighting and language support for the languages used in this tutorial, VS Code can be configured with these extensions. Erlang Elixir Python Versions These distribution versions are used in this tutorial. Your installed versions need not exactly match, but we document these in case of any problems you might face when working through the tutorial later on. Name Version Erlang/ OTP 23.3.2 Elixir 1.11.4 Python 3.9.4 PIP 21.0.1 VS Code 1.56.0 Now that your system is set up, we can proceed to download and compile detectEr.","title":"Adding extensions"},{"location":"getting-started/quickstart.html","text":"Quickstart \u00b6 Launching detectEr from the shell \u00b6 The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example. Hello world \u00b6 Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1> hello : greet ( \"Duncan\" ). Hello there, Duncan! ok 2> 5. Quit the Erlang shell by typing q (). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . We refer to functions in the same module simply as fun / arity . Hello world, the asynchronous way \u00b6 You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations . We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 5 ) to launch hello : greet / 1 as a process, returning the new process ID. Process IDs ( PIDs for short) are triples of the form < A . B . C > that uniquely identify Erlang processes executing on the EVM . spawn / 3 is parametrised by the module name, the name of the function to spawn, and the list of arguments accepted by the function. Function start_greet / 1 makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 97 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID of the spawned process < 0 . 97 . 0 > instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell. Outline runtime monitoring \u00b6 In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample prop_hello.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/prop_hello.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam prop_hello . beam ... The analyser prop_hello exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test prop_hello : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > prop_hello : mfa_spec ({ hello , greet , [ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello, greet, [\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet , [ \"Duncan\" ]}, fun prop_hello : mfa_spec / 1 , []). The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun prop_hello : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In this introductory example, the analyser prop_hello promptly terminates with the verdict no as soon as our hello world program starts executing. The no verdict informs us that a program has violated the specification of prop_hello.hml . We next look at a typical concurrent program where processes interact, and study what kind of useful properties one might want such systems to observe.","title":"Quickstart"},{"location":"getting-started/quickstart.html#quickstart","text":"","title":"Quickstart"},{"location":"getting-started/quickstart.html#launching-detecter-from-the-shell","text":"The detecter/ebin directory created previously needs to be included in the Erlang runtime path to preload all the binaries required to be able to use detectEr. This is done by using the -pa switch when launching the Erlang shell. [duncan@local]:$ erl -pa /path/to/detecter/ebin Once loaded, detectEr can be used to monitor systems that execute on the Erlang Virtual Machine. It also supports the monitoring of systems that run outside of the EVM , provided that these record their logs in files following a predetermined formatting that enables detectEr to extract runtime information. This topic is covered in more depth in the Instrumentation section. For now, we establish the workflow required to use detectEr by way of the traditional \u2018hello world\u2019 example.","title":"Launching detectEr from the shell"},{"location":"getting-started/quickstart.html#hello-world","text":"Before using detectEr, you should get an intuitive grasp of what monitoring is, and the steps one needs to follow to initialise and start the monitoring process. If this is your first time using Erlang, the following wil help you get acquainted with the Erlang shell. Launch a new terminal emulator window ( e.g. Terminal on Ubuntu or macOS), navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. BEAM files are (fairly) portable binaries consisting of bytecode that is interpreted by the EVM , similar to how Java operates. [duncan@local]:/detecter/examples/erlang$ make rm -f ebin/*.beam ebin/*.E ebin/*.tmp erl_crash.dump ebin/*.app ... [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 7 duncan duncan 224 May 17 17:16 ebin drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src 3. Launch the Erlang shell erl . We add the binaries of the ebin directory to the Erlang code path via the -pa flag to load and make them accessible from the shell. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> 4. The Erlang shell allows you to type expressions and execute them by pressing Enter . Every expression typed on the shell must be terminated with a full-stop. Try invoking the function greet of the hello module. The function greet accepts one argument, the name of the person to greet, specified as a string enclosed within double quotes. 1> hello : greet ( \"Duncan\" ). Hello there, Duncan! ok 2> 5. Quit the Erlang shell by typing q (). Function signatures In Erlang (and Elixir), functions are uniquely identified via the triple mod : fun / arity , where mod is the module name, fun , the name of the function contained in the module, and arity , the number of arguments that the function accepts. This reference format is commonly known as MFA . For example, our greet function inside the module hello can be concisely referred to as hello : greet / 1 . We refer to functions in the same module simply as fun / arity .","title":"Hello world"},{"location":"getting-started/quickstart.html#hello-world-the-asynchronous-way","text":"You might have noticed that hello : greet / 1 pauses the Erlang shell momentarily before the greeting is displayed. During this interval, the shell is inoperable and cannot accept user input. Such function calls are called synchronous invocations, since they block the caller until the called function returns, i.e. the body of the called function is executed in its entirety and a value is returned to the caller. Examining the body of greet below makes it clear why the Erlang shell stops responding when the function call is effected. 1 2 3 greet ( Name ) -> timer : sleep ( 5000 ), % Pause for 5 seconds to simulate some work.. io : format ( \"Hello there, ~s ! ~n \" , [ Name ]). Line 1 defines the function greet that accepts Name as parameter, while line 3 prints the greeting on the Erlang shell via call to io : format / 2 . The call timer : sleep ( 5000 ) on line 2 pauses the caller process ( i.e. the Erlang shell, in this case) for 5000 ms before executing the rest of the function body. In Erlang, the function return value is the result of the last expression in the function body; for the case of greet , this value is the atom ok that is returned by io : format / 2 . Synchronous calls Synchronous function calls are useful when one needs to ensure that certain processes execute in some prescribed order with respect to one another, e.g. in lock step. This mode of interaction is common to many standard communication protocols such as HTTP , SMTP , DNS , etc. Unwanted synchrony can be easily avoided by launching functions to execute as independent processes that run concurrently with other processes in the system. To this end, Erlang provides the Built-in Functions spawn / { 1 - 4 } , and their variations . We slightly tweak our hello world example to spawn hello : greet / 1 as a separate process that executes concurrently with the Erlang shell process. 4 5 start_greet ( Name ) when is_list ( Name ) -> spawn ( ? MODULE , greet , [ Name ]). The function start_greet / 1 implements this modification. It uses the BIF spawn / 3 (line 5 ) to launch hello : greet / 1 as a process, returning the new process ID. Process IDs ( PIDs for short) are triples of the form < A . B . C > that uniquely identify Erlang processes executing on the EVM . spawn / 3 is parametrised by the module name, the name of the function to spawn, and the list of arguments accepted by the function. Function start_greet / 1 makes use of the predefined macro ? MODULE , that gets replaced with the name of the module it appears in when the source code of the hello module is preprocessed by the Erlang compiler. Concretely, the invocation to spawn/3 on line 5 yields the source code spawn ( hello , greet , [ Name ]) prior to compilation. Restart the Erlang shell and invoke hello : start_greet / 1 . 1 > hello : start_greet ( \"Duncan\" ). < 0 . 97 . 0 > Hello there , Duncan ! % Shown after a slight pause. 2 > Observe that now: The return value of start_greet is the PID of the spawned process < 0 . 97 . 0 > instead of the atom ok ; The Erlang shell does not block, but returns immediately; After the predefined sleep time elapses, the greeting is printed to the shell.","title":"Hello world, the asynchronous way"},{"location":"getting-started/quickstart.html#outline-runtime-monitoring","text":"In this quickstart demo, we monitor the execution of our asynchronous hello world example using the outline form of instrumentation. Launch the shell as previous, adding the hello world binaries in ebin to the Erlang code path. The detectEr binaries compiled earlier are also included. [duncan@local]:/detecter/examples/erlang$ erl -pa ebin ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Compile the sample prop_hello.hml property script to generate the corresponding analyser binary. 1 > hml_eval : compile ( \"props/prop_hello.hml\" , [{ outdir , \"ebin\" }, v ]). This compilation procedure, known as the synthesis , translates sHML specifications written in *.hml script files to their analyser equivalents. For now, it suffices to know that sHML \u2014the logic used by detectEr\u2014expresses properties of the system one wishes to runtime verify. Our analyser Erlang binary generated from the sample property is placed in /detecter/examples/erlang/ebin and automatically loaded for use in the shell code path. 2 > ls ( \"ebin\" ). hello . beam prop_hello . beam ... The analyser prop_hello exposes a single function, mfa_spec / 1 , that accepts the MFArgs triple { Mod , Fun , Args } designating the Erlang process to be analysed. Specifically, Mod , Fun and Args are the components of the function passed as arguments to spawn / 3 . For our hello world example, Mod is the atom hello , Fun is the function name greet , and Args , the singleton argument list containing the name of the person to be greeted. You can test prop_hello : mfa_spec / 1 analyser function by providing the triple { hello , greet , [ \"Duncan\" ]} . 3 > prop_hello : mfa_spec ({ hello , greet , [ \"Duncan\" ]}). *** [ < 0 . 82 . 0 > ] Instrumenting monitor for MFA pattern '{hello, greet, [\"Duncan\"]}' . *** [ < 0 . 82 . 0 > ] Reached verdict 'no' . Launch the monitored system. 4 > monitor : start_online ({ hello , start_greet , [ \"Duncan\" ]}, fun prop_hello : mfa_spec / 1 , []). The function monitor : start_online / 3 accepts three arguments: a MFArgs describing the function that is to be spawned as an Erlang process, the analyser function, and a list of options . Setting MFArgs to { hello , start_greet ,[ \"Duncan\" ]} and the analyser to fun prop_hello : mfa_spec / 1 launches the hello world and analyser processes to execute concurrently. In this introductory example, the analyser prop_hello promptly terminates with the verdict no as soon as our hello world program starts executing. The no verdict informs us that a program has violated the specification of prop_hello.hml . We next look at a typical concurrent program where processes interact, and study what kind of useful properties one might want such systems to observe.","title":"Outline runtime monitoring"},{"location":"getting-started/setting-up-detecter.html","text":"Setting up detectEr \u00b6 Downloading detectEr \u00b6 detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license Compiling detectEr \u00b6 For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr With detectEr compiled, let us move on to our first \u2018hello world\u2019 example!","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#setting-up-detecter","text":"","title":"Setting up detectEr"},{"location":"getting-started/setting-up-detecter.html#downloading-detecter","text":"detectEr can be cloned from our GitHub repository: git clone https://github.com/duncanatt/detecter.git You can also download detectEr in archive format by visiting https://github.com/duncanatt/detecter , or by running: wget -O detecter.zip https://github.com/duncanatt/detecter/archive/refs/heads/master.zip unzip detecter.zip mv detecter-master detecter Unzip If the unzip utility is not installed on your Ubuntu/Debian system, you can install it via APT by running sudo apt install unzip . On macOS, unzip is pre-installed. Both of these actions should result in the creation of the directory detecter that is structured as follows. Directory name Description detecter detectEr root directory detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros Makefile Makefile with targets for compiling and testing detectEr examples Tutorial examples erlang Calculator server implementation in Erlang src Erlang module sources props sHML property specifications Makefile Makefile with targets for compiling the example elixir Calculator server implementation in Elixir lib Elixir module sources props sHML property specifications Makefile Makefile with targets for compiling the example python Calculator server implementation in Python using TCP sockets src Python script sources props sHML property specifications Makefile Makefile with targets for compiling the example LICENSE GPL3 license","title":"Downloading detectEr"},{"location":"getting-started/setting-up-detecter.html#compiling-detecter","text":"For this tutorial, we do not use sophisticated code building mechanisms such as rebar, but stick to the make utility to standardise our build processes. Ubuntu/Debian On Ubuntu/Debian, GNU make can be installed using APT . Refresh the package manager repository cache: sudo apt update . Install make: sudo apt install make . Alternatively, you may choose to install the full build-essential package which includes make . macOS macOS users need to download and install the Apple Developer Command Line Tools which includes make . Run the command: xcode-select --install . In the ensuing dialog, click Install and agree to the Terms of Service. You can also install GNU make using Homebrew by typing: brew install make . Windows 10 Windows 10 users not using WSL can install GNU make via Chocolatey by running: choco install make . detectEr and its accompanying code examples comes bundled with the necessary makefiles to facilitate their use. To compile detectEr, navigate to the root detecter project directory. Change the current directory to the detecter tool directory: cd detecter . Execute make . A new ebin directory is created, containing the compiled Erlang source modules as *.beam executables. The detecter directory now looks as follows: Directory name Description detecter detectEr tool directory priv detectEr language specification and other configuration files src Erlang module sources test Unit tests include Supporting macros ebin Compiled detectEr files Makefile Makefile with targets for compiling and testing detectEr With detectEr compiled, let us move on to our first \u2018hello world\u2019 example!","title":"Compiling detectEr"},{"location":"using-detecter/formalising-properties.html","text":"Formalising Properties \u00b6 Choosing what to analyse \u00b6 detectEr provides the keywords with and monitor to target program processes for a particular sHML specification. The with keyword picks out the signature of the function that is spawned as a process, whereas the monitor keyword defines the property to be runtime analysed. For example, to verify the behaviour of our calculator process against a sHML formula \u03c6 , we write: with calc_server : loop (_) monitor \u03c6 From an instrumentation standpoint, with establishes the set of trace events corresponding to the program process it targets, thus enabling the specification to abstract from the events that are generated by other processes. This helps maintain the size of sHML specifications compact whenever possible. In using with , our formula need not account for superfluous trace events ( e.g. of another calculator process) that tend to make the specification exercise tedious and error-prone. Let us formalise the properties from the Getting Started section; these are specified with respect to the five process events fork , init , exit , send , and recv supported by detectEr. We include our calculator server transition model for reference. @import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt, stp } Srv ? {Clt,stp} Srv:Clt ! { bye ,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! { ok ,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{ add ,A,B}} Srv ? {Clt,{add,A,B}} Srv:Clt ! { ok ,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{ mul ,A,B}} Srv ? {Clt,{mul,A,B}} Viewer does not support full SVG 1.1 Formalising P 1 \u00b6 (P 1 ) The service request count returned on shutdown is never negative. P 1 is an extension of the property that we have already seen earlier, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff , that requires the program state \u201cnot to exhibit a send event whose payload consists of { bye , Tot } where Tot is negative.\u201d While in principle, this sHML formula is correct, it does not account for the other program events that our calculator server can exhibit from one of its states. For example, from Q0 , the server exhibits recv events that are ignored by the formula; similarly, from Q2 , the server transitions with a send event to Q1 , but the message payload is not the one we are after. We remedy this by adding clauses that handle these possibilities. 1 2 3 4 5 6 7 8 9 10 11 with calc_server : loop (_) monitor and ([ Lnc <- Srv , calc_server : loop ( Args )] max ( X . and ( [ Srv ? Clt ] X , [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff , [ Srv : Clt ! { Ack , Ans } when Ack =:= ok orelse ( Ack =:= bye andalso Ans >= 0 )] X ) ). Using with .. monitor , we designate the spawned calculator server loop function calc_server : loop / 1 as the process to be analysed against the formalisation of property P 1 (lines 1 - 3 ). Our formalisation of P 1 consists of two conjuncted necessities , i.e. , and (...) . The first conjuncted necessity on line 4 handles the init event exhibited by every process upon initialisation (we remark that init was elided in the transition model of our calculator server to simplify our discussion, but we need to account for it!). The second nested and (...) on line 6 includes the additional necessities that cover the other possible events produced by the transition system above, recursing on the fix-point variable X (lines 7 and 9 ). Line 8 shows our earlier formula [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff that then checks for the condition imposed by P 1 . There are a couple of comments that are in order. First, the constraints on lines 8 and 9 ensure mutual exclusivity between the two necessities, i.e. , either Tot < 0 or, Ans >= 0 only when the acknowledgement is the atom bye . Second, you may observe that the sub-formula on line 8 alone seems to capture the core requirement of property P 1 . This line of reasoning is partially right. However, to interpret the requirement stated informally (in English) by P 1 and formalise it unambiguously , one must take the transition model into account. In fact, formalising P 1 for a different transition system potentially yields a specification that is altogether unlike the one above for our calculator server. Specific to our transition model, the necessities on lines 7 and 9 act as filters that \u2018eat up\u2019 the non-relevant program events. Note Variables Lnc , Srv , and Clt in our formalisation of P 1 are included assist in our explanation, but can be replaced with the don\u2019t care pattern _ since these are unused in constraints. We omit such variables going forward. Reformulating P 1 \u00b6 P 1 safeguards against the calculator returning a negative request total when shut down. An examination of calc_server : loop / 1 promptly reveals that a non-negative request total returned on server shutdown does not necessarily mean that the number of tracked client requests is correct. In fact, starting the server loop with any number other than 0 will always yield an incorrect request total. Let us rectify this oversight by reformulating P 1 . (P\u2019 1 ) The initial service request count must be 0. Its corresponding formalisation leverages the init event pattern, simplifying the formula considerably: 1 2 3 4 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop ([ Tot ]) where Tot =/= 0 ] ff ). Line 4 consists of the singleton conjuncted necessity where the event pattern matches the spawned function against the module and function name atoms, calc_server and loop , respectively. The list pattern [] matches the argument list containing exactly one argument whose must be 0 . Formalising P 2 \u00b6 (P 2 ) Replies are always sent to the client indicated in the request. P 2 describes a fragment of the client-server protocol, asserting that server replies are always addressed to the clients issuing them. Unlike the properties seen thus far, this requirement induces data dependency between client requests and server responses. 1 2 3 4 5 6 7 8 9 10 11 12 13 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X ) ) ) ). Our formalisation of P 2 expresses this data dependency in the nested formulae above via the binders Srv_1 and Clt_1 , that are used in the constraint of the sub-formulae on lines 8 and 9 . Srv_1 =:= Srv_2 scopes our reasoning to single server instance, i.e. , the same calculator server process. The formula is violated when Clt_1 =/= Clt_2 (since the continuation would need to satisfy ff ), and recurs on variable X otherwise. Recall that the comparisons between the different variable instantiations is possible since the binding scope of the event pattern variables Srv_1 and Clt_1 in the outer necessity extends to the context of the inner and (...) on lines 7 - 10 . Refining P 2 \u00b6 The formalisation of P 2 above does not account for the case where the server interacts with more than one client. It disregards the possibility of interleaved execution, which is inherent to concurrent settings where processes are unable to control when messages are received. For instance, while the sub-formula [ Srv_1 ? { Clt_1 , _}] on line 6 matches an initial recv event, an ensuing recv event ( e.g. due to a second client that happens to interact with the server) satisfies neither of the necessities on lines 8 and 9 . This does not reflect the requirement of our original property P 2 , and is yet another manifestation of the issue encountered earlier , i.e. , formalising a property must be done in connection to the context in which the program operates. We handle this inconvenience by augmenting the formula to filter non-relevant events, as previous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] max ( Y . and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X , [_ ? _] Y ) ) ) ) ). Formalising P 3 \u00b6 (P 3 ) A request for adding two numbers always returns their sum. P 3 demonstrates how we can use constraints to perform more complex reasoning on program event data, besides equality and range checks. 1 2 3 4 5 6 7 8 9 10 11 12 13 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([_ ? {_, { add , A , B }}] and ( [_:_ ! { ok , Res } when Res =/= A + B ] ff , [_:_ ! { ok , Res } when Res =:= A + B ] X ) ) ) ) This sHML formula compares the result issued by the server, instantiated in the variable Res , against the sum of the values instantiated in A and B . Necessity [_ ? {_, { add , A , B }}] on line 6 corresponds to the server receiving and addition request from a client, consisting of the payload { add , A , B } . A and B are added and compared to the server result embedded in the payload of the send event exhibited by the server in the nested necessities on lines 8 and 9 . The first sub-formula (line 8 ) handles the case where the addition is incorrectly executed by the server, whereas the second sub-formula (line 9 ) is satisfied when the addition is correct, unfolding the formula via recursion on variable X . Formalising P 4 \u00b6 (P 4 ) Client requests are never serviced more than once. P 4 specifies a control aspect of the client-server interaction. The corresponding sHML formula expresses this requirement via a guarded fix-point that recurs on X for sequences of send - recv events. This recursion captures normal server operation that corresponds to the sub-formula on line 5 followed by the one on line 7 , and then [_ ? _] X on line 10 followed thereafter by the sub-formula of line 7 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] and ([_ ? _] max ( X . and ([ Srv_1 : Clt_1 ! _] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] ff , [_ ? _] X ) ) ) ) ). Our formula is violated when a send event matched by [ Srv_1 : Clt_1 ! _] is followed by a second send that is matched by the sub-formula on line 9 . The constraint Clt_1 =:= Clt_2 of the necessity on line 9 ensures that duplicate send events concern the same recipient. Having formalised properties P 1 , P 2 , P 3 , and P 4 , we are now in a position to use detectEr and synthesise the corresponding analysers in Erlang code. But before doing that, we need to discuss how the runtime setting limits our view of program behaviour, and how analysers fit in the picture.","title":"Formalising Properties"},{"location":"using-detecter/formalising-properties.html#formalising-properties","text":"","title":"Formalising Properties"},{"location":"using-detecter/formalising-properties.html#choosing-what-to-analyse","text":"detectEr provides the keywords with and monitor to target program processes for a particular sHML specification. The with keyword picks out the signature of the function that is spawned as a process, whereas the monitor keyword defines the property to be runtime analysed. For example, to verify the behaviour of our calculator process against a sHML formula \u03c6 , we write: with calc_server : loop (_) monitor \u03c6 From an instrumentation standpoint, with establishes the set of trace events corresponding to the program process it targets, thus enabling the specification to abstract from the events that are generated by other processes. This helps maintain the size of sHML specifications compact whenever possible. In using with , our formula need not account for superfluous trace events ( e.g. of another calculator process) that tend to make the specification exercise tedious and error-prone. Let us formalise the properties from the Getting Started section; these are specified with respect to the five process events fork , init , exit , send , and recv supported by detectEr. We include our calculator server transition model for reference. @import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt, stp } Srv ? {Clt,stp} Srv:Clt ! { bye ,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! { ok ,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{ add ,A,B}} Srv ? {Clt,{add,A,B}} Srv:Clt ! { ok ,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{ mul ,A,B}} Srv ? {Clt,{mul,A,B}} Viewer does not support full SVG 1.1","title":"Choosing what to analyse"},{"location":"using-detecter/formalising-properties.html#formalising-p1","text":"(P 1 ) The service request count returned on shutdown is never negative. P 1 is an extension of the property that we have already seen earlier, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff , that requires the program state \u201cnot to exhibit a send event whose payload consists of { bye , Tot } where Tot is negative.\u201d While in principle, this sHML formula is correct, it does not account for the other program events that our calculator server can exhibit from one of its states. For example, from Q0 , the server exhibits recv events that are ignored by the formula; similarly, from Q2 , the server transitions with a send event to Q1 , but the message payload is not the one we are after. We remedy this by adding clauses that handle these possibilities. 1 2 3 4 5 6 7 8 9 10 11 with calc_server : loop (_) monitor and ([ Lnc <- Srv , calc_server : loop ( Args )] max ( X . and ( [ Srv ? Clt ] X , [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff , [ Srv : Clt ! { Ack , Ans } when Ack =:= ok orelse ( Ack =:= bye andalso Ans >= 0 )] X ) ). Using with .. monitor , we designate the spawned calculator server loop function calc_server : loop / 1 as the process to be analysed against the formalisation of property P 1 (lines 1 - 3 ). Our formalisation of P 1 consists of two conjuncted necessities , i.e. , and (...) . The first conjuncted necessity on line 4 handles the init event exhibited by every process upon initialisation (we remark that init was elided in the transition model of our calculator server to simplify our discussion, but we need to account for it!). The second nested and (...) on line 6 includes the additional necessities that cover the other possible events produced by the transition system above, recursing on the fix-point variable X (lines 7 and 9 ). Line 8 shows our earlier formula [ Srv : Clt ! { bye , Tot } when Tot < 0 ] ff that then checks for the condition imposed by P 1 . There are a couple of comments that are in order. First, the constraints on lines 8 and 9 ensure mutual exclusivity between the two necessities, i.e. , either Tot < 0 or, Ans >= 0 only when the acknowledgement is the atom bye . Second, you may observe that the sub-formula on line 8 alone seems to capture the core requirement of property P 1 . This line of reasoning is partially right. However, to interpret the requirement stated informally (in English) by P 1 and formalise it unambiguously , one must take the transition model into account. In fact, formalising P 1 for a different transition system potentially yields a specification that is altogether unlike the one above for our calculator server. Specific to our transition model, the necessities on lines 7 and 9 act as filters that \u2018eat up\u2019 the non-relevant program events. Note Variables Lnc , Srv , and Clt in our formalisation of P 1 are included assist in our explanation, but can be replaced with the don\u2019t care pattern _ since these are unused in constraints. We omit such variables going forward.","title":"Formalising P1"},{"location":"using-detecter/formalising-properties.html#reformulating-p1","text":"P 1 safeguards against the calculator returning a negative request total when shut down. An examination of calc_server : loop / 1 promptly reveals that a non-negative request total returned on server shutdown does not necessarily mean that the number of tracked client requests is correct. In fact, starting the server loop with any number other than 0 will always yield an incorrect request total. Let us rectify this oversight by reformulating P 1 . (P\u2019 1 ) The initial service request count must be 0. Its corresponding formalisation leverages the init event pattern, simplifying the formula considerably: 1 2 3 4 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop ([ Tot ]) where Tot =/= 0 ] ff ). Line 4 consists of the singleton conjuncted necessity where the event pattern matches the spawned function against the module and function name atoms, calc_server and loop , respectively. The list pattern [] matches the argument list containing exactly one argument whose must be 0 .","title":"Reformulating P1"},{"location":"using-detecter/formalising-properties.html#formalising-p2","text":"(P 2 ) Replies are always sent to the client indicated in the request. P 2 describes a fragment of the client-server protocol, asserting that server replies are always addressed to the clients issuing them. Unlike the properties seen thus far, this requirement induces data dependency between client requests and server responses. 1 2 3 4 5 6 7 8 9 10 11 12 13 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X ) ) ) ). Our formalisation of P 2 expresses this data dependency in the nested formulae above via the binders Srv_1 and Clt_1 , that are used in the constraint of the sub-formulae on lines 8 and 9 . Srv_1 =:= Srv_2 scopes our reasoning to single server instance, i.e. , the same calculator server process. The formula is violated when Clt_1 =/= Clt_2 (since the continuation would need to satisfy ff ), and recurs on variable X otherwise. Recall that the comparisons between the different variable instantiations is possible since the binding scope of the event pattern variables Srv_1 and Clt_1 in the outer necessity extends to the context of the inner and (...) on lines 7 - 10 .","title":"Formalising P2"},{"location":"using-detecter/formalising-properties.html#refining-p2","text":"The formalisation of P 2 above does not account for the case where the server interacts with more than one client. It disregards the possibility of interleaved execution, which is inherent to concurrent settings where processes are unable to control when messages are received. For instance, while the sub-formula [ Srv_1 ? { Clt_1 , _}] on line 6 matches an initial recv event, an ensuing recv event ( e.g. due to a second client that happens to interact with the server) satisfies neither of the necessities on lines 8 and 9 . This does not reflect the requirement of our original property P 2 , and is yet another manifestation of the issue encountered earlier , i.e. , formalising a property must be done in connection to the context in which the program operates. We handle this inconvenience by augmenting the formula to filter non-relevant events, as previous. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([ Srv_1 ? { Clt_1 , _}] max ( Y . and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =/= Clt_2 ] ff , [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] X , [_ ? _] Y ) ) ) ) ).","title":"Refining P2"},{"location":"using-detecter/formalising-properties.html#formalising-p3","text":"(P 3 ) A request for adding two numbers always returns their sum. P 3 demonstrates how we can use constraints to perform more complex reasoning on program event data, besides equality and range checks. 1 2 3 4 5 6 7 8 9 10 11 12 13 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] max ( X . and ([_ ? {_, { add , A , B }}] and ( [_:_ ! { ok , Res } when Res =/= A + B ] ff , [_:_ ! { ok , Res } when Res =:= A + B ] X ) ) ) ) This sHML formula compares the result issued by the server, instantiated in the variable Res , against the sum of the values instantiated in A and B . Necessity [_ ? {_, { add , A , B }}] on line 6 corresponds to the server receiving and addition request from a client, consisting of the payload { add , A , B } . A and B are added and compared to the server result embedded in the payload of the send event exhibited by the server in the nested necessities on lines 8 and 9 . The first sub-formula (line 8 ) handles the case where the addition is incorrectly executed by the server, whereas the second sub-formula (line 9 ) is satisfied when the addition is correct, unfolding the formula via recursion on variable X .","title":"Formalising P3"},{"location":"using-detecter/formalising-properties.html#formalising-p4","text":"(P 4 ) Client requests are never serviced more than once. P 4 specifies a control aspect of the client-server interaction. The corresponding sHML formula expresses this requirement via a guarded fix-point that recurs on X for sequences of send - recv events. This recursion captures normal server operation that corresponds to the sub-formula on line 5 followed by the one on line 7 , and then [_ ? _] X on line 10 followed thereafter by the sub-formula of line 7 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 with calc_server : loop (_) monitor and ([_ <- _, calc_server : loop (_)] and ([_ ? _] max ( X . and ([ Srv_1 : Clt_1 ! _] and ( [ Srv_2 : Clt_2 ! _ when Srv_1 =:= Srv_2 andalso Clt_1 =:= Clt_2 ] ff , [_ ? _] X ) ) ) ) ). Our formula is violated when a send event matched by [ Srv_1 : Clt_1 ! _] is followed by a second send that is matched by the sub-formula on line 9 . The constraint Clt_1 =:= Clt_2 of the necessity on line 9 ensures that duplicate send events concern the same recipient. Having formalised properties P 1 , P 2 , P 3 , and P 4 , we are now in a position to use detectEr and synthesise the corresponding analysers in Erlang code. But before doing that, we need to discuss how the runtime setting limits our view of program behaviour, and how analysers fit in the picture.","title":"Formalising P4"},{"location":"using-detecter/getting-started.html","text":"Getting Started \u00b6 A Calculator program in Erlang \u00b6 Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation. The calculator server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The calculator server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the type of operation to be executed on the server side, its arguments (if applicable), and the client PID to whom the corresponding server reply is addressed. Our calculator program is implemented as the Erlang module calc_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( Tot ) -> receive { Clt , { add , A , B }} -> Clt ! { ok , A + B }, loop ( Tot + 1 ); { Clt , { mul , A , B }} -> Clt ! { ok , A * B }, loop ( Tot + 1 ); { Clt , stp } -> % Stop service. Clt ! { bye , Tot } end . calc_server : loop / 1 encapsulates the calculator server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes calc_server : start / 1 for some integer argument N . The spawned server consumes a message request from its mailbox via the receive expression on lines 5-16 , and pattern matches against one of the three types of operations requested by clients: Addition ( add ) and multiplication ( mul ) requests that carry the operands A and B (lines 6 and 10 ), and, stop ( stp ) requests that carries no arguments (line 14 ). Pattern matching instantiates the variables Clt , A and B to concrete data in client request messages. Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , lines 6 , 10 , and 14 . Server replies carry the status tag (an atom) ok or bye , and the result of the requested operation. The server uses the parameter Tot of loop / 1 to track the number of requests serviced, and is returned in reply to a stp operation. After handling add and mul requests, the server executes loop / 1 to recommence the process loop and service the next client request, incrementing the request count accordingly (lines 8 and 12 ); the tail recursive call to loop / 1 is not made for stp requests, and the calculator server process terminates naturally. The logic of loop / 1 induces a server runtime behaviour that can be abstractly described by the transition system model below. @import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt, stp } Srv ? {Clt,stp} Srv:Clt ! { bye ,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! { ok ,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{ add ,A,B}} Srv ? {Clt,{add,A,B}} Srv:Clt ! { ok ,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{ mul ,A,B}} Srv ? {Clt,{mul,A,B}} Viewer does not support full SVG 1.1 States of the model capture the internal state that the server process can be in at any point during its execution. Transitions between states denote the computational steps of the program that produce visible program events . For instance, the event Srv ? { Clt , stp } is exhibited by the server loop when the calculator at its initial state Q0 reads a stp request from its mailbox and transitions to Q3 . This transition depicts the computation that loop / 1 performs to receive the stp request, line 5 , and subsequently pattern match it to { Clt , stp } on line 14 . Note that events in the model capture the set of all possible concrete events that the running program can exhibit, e.g. , Srv ? { Clt , stp } describes all receive events where the variable placeholders Srv and Clt range over PIDs , and stp is the atom denoting the stop operation requested by clients. Safety properties \u00b6 There are a number of properties we would like the server behaviour to observe. For example, the server loop does not control the initial value of Tot that an invocation to calc_server : start / 1 provides. We could, therefore, require that: (P 1 ) The service request count returned on shutdown is never negative. Similarly, we would expect that (P 2 ) Replies are always sent to the client indicated in the request, and that (P 3 ) A request for adding two numbers always returns their sum both hold, amongst others. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. Besides properties that reason about data, our server logic is expected to comply with control properties, such as, (P 4 ) Client requests are never serviced more than once. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour programs must comply with.","title":"Getting Started"},{"location":"using-detecter/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"using-detecter/getting-started.html#a-calculator-program-in-erlang","text":"Let us consider an archetypal calculator program consisting of a single server process that handles client requests for arithmetic computation. The calculator server blocks and waits for requests sent as asynchronous messages. These messages are addressed to the server using its PID , and deposited in the server mailbox that buffers multiple client requests. The calculator server unblocks upon reading a message from its mailbox. In our client-server protocol, messages contain the type of operation to be executed on the server side, its arguments (if applicable), and the client PID to whom the corresponding server reply is addressed. Our calculator program is implemented as the Erlang module calc_server that can be found under examples/erlang/src . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 start ( N ) -> spawn ( ? MODULE , loop , [ N ]). loop ( Tot ) -> receive { Clt , { add , A , B }} -> Clt ! { ok , A + B }, loop ( Tot + 1 ); { Clt , { mul , A , B }} -> Clt ! { ok , A * B }, loop ( Tot + 1 ); { Clt , stp } -> % Stop service. Clt ! { bye , Tot } end . calc_server : loop / 1 encapsulates the calculator server logic that is spawned by some other launcher process ( e.g. the Erlang shell) that invokes calc_server : start / 1 for some integer argument N . The spawned server consumes a message request from its mailbox via the receive expression on lines 5-16 , and pattern matches against one of the three types of operations requested by clients: Addition ( add ) and multiplication ( mul ) requests that carry the operands A and B (lines 6 and 10 ), and, stop ( stp ) requests that carries no arguments (line 14 ). Pattern matching instantiates the variables Clt , A and B to concrete data in client request messages. Every request fulfilled by the server results in a corresponding reply that it sends to the PID of the client instantiated in variable Clt , lines 6 , 10 , and 14 . Server replies carry the status tag (an atom) ok or bye , and the result of the requested operation. The server uses the parameter Tot of loop / 1 to track the number of requests serviced, and is returned in reply to a stp operation. After handling add and mul requests, the server executes loop / 1 to recommence the process loop and service the next client request, incrementing the request count accordingly (lines 8 and 12 ); the tail recursive call to loop / 1 is not made for stp requests, and the calculator server process terminates naturally. The logic of loop / 1 induces a server runtime behaviour that can be abstractly described by the transition system model below. @import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt, stp } Srv ? {Clt,stp} Srv:Clt ! { bye ,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! { ok ,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{ add ,A,B}} Srv ? {Clt,{add,A,B}} Srv:Clt ! { ok ,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{ mul ,A,B}} Srv ? {Clt,{mul,A,B}} Viewer does not support full SVG 1.1 States of the model capture the internal state that the server process can be in at any point during its execution. Transitions between states denote the computational steps of the program that produce visible program events . For instance, the event Srv ? { Clt , stp } is exhibited by the server loop when the calculator at its initial state Q0 reads a stp request from its mailbox and transitions to Q3 . This transition depicts the computation that loop / 1 performs to receive the stp request, line 5 , and subsequently pattern match it to { Clt , stp } on line 14 . Note that events in the model capture the set of all possible concrete events that the running program can exhibit, e.g. , Srv ? { Clt , stp } describes all receive events where the variable placeholders Srv and Clt range over PIDs , and stp is the atom denoting the stop operation requested by clients.","title":"A Calculator program in Erlang"},{"location":"using-detecter/getting-started.html#safety-properties","text":"There are a number of properties we would like the server behaviour to observe. For example, the server loop does not control the initial value of Tot that an invocation to calc_server : start / 1 provides. We could, therefore, require that: (P 1 ) The service request count returned on shutdown is never negative. Similarly, we would expect that (P 2 ) Replies are always sent to the client indicated in the request, and that (P 3 ) A request for adding two numbers always returns their sum both hold, amongst others. These properties are data-dependent , which makes them hard to ascertain using static techniques such as type systems. Besides properties that reason about data, our server logic is expected to comply with control properties, such as, (P 4 ) Client requests are never serviced more than once. The properties mentioned thus far phrase the correctness requirement as a guarantee that the program must always provide. Such properties are called safety properties , since they stipulate that \u201cfor any sort of behaviour that the program can do, nothing bad ever happens.\u201d As a consequence of this condition, showing that a program violates a safety property entails finding just one instance of a program execution that exhibits bad behaviour. Producing this evidence is enough of a proof that the program under scrutiny is not safe with respect to the property in question. The next section explains how these properties can be expressed in a logic that precisely and unambiguously establishes the behaviour programs must comply with.","title":"Safety properties"},{"location":"using-detecter/inline-instrumentation.html","text":"Inline Instrumentation \u00b6 Overview \u00b6 Inlining is the most efficient instrumentation approach detectEr offers. While it assumes access to the program source code, it carries benefits such as low runtime overhead and immediate detections. There are various other RV tools, especially those targeting the JVM, that adopt inlining as their instrumentation method of choice, using libraries such as AspectJ and ASM . One drawback of inlining is that it tends to be invasive, and cannot be used in scenarios where the program code is not available ( e.g. compiled versions of the program, licensing agreements, etc. ). detectEr employs a custom-built weaver to instrument invocations to analysers via code injection, by manipulating the program abstract syntax tree. This procedure is detailed in the companion paper ; readers are encouraged to consult this resource for more details. Here, we will learn how to use detectEr to inline and analyse programs for which the source code is available. Once more, we rely on our Erlang implementation of the calculator server from the Getting Started section to show how this is done. The calculator server program \u00b6 Let us run the calculator server program with no instrumentation applied, to familiarise ourselves with its basic operation. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. Launch the Erlang shell erl . We add the detectEr binaries and the ones we have just compiled to the shell code path via -pa . [duncan@local]:/detecter/examples/erlang$ erl -pa ../../detecter/ebin ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> The calculator server is started by invoking calc_server : start / 1 . If you recall from the section Getting Started , start / 1 accepts a single argument N that it uses to track the number of requests handled. Function start / 1 spawns the server process and returns its PID . We need to hold on to this PID in order to use it to communicate with our server. To do this, we store the PID in the variable Pid . 1> Pid = calc_server : start ( 0 ). <0.86.0> We can check that the server process has actually started using the is_process_alive/1 BIF . 2> is_process_alive ( Pid ). true The server is now ready to handle client requests. Messages in Erlang are submitted using the send operator, ! , that takes the PID of the recipient process and the message to send as arguments. The data in the request message we send must coincide with one of the clauses that the server is able to pattern match in its receive expression. When this is not the case, the message is not processed, and left queued in the calculator server mailbox. Try instructing the server to add two numbers, 10 and 97 . 3> Pid ! { self (), { add , 10 , 97 }}. {<0.84.0>,{add,10,97}} Let us dissect our request message. It consists of the pair containing the PID of the Erlang shell, which we obtain through the BIF self / 0 , and the payload, { add , 10 , 97 } . Send expressions in Erlang evaluate to the message sent, which is why the shell prints the output { < 0 . 84 . 0 > ,{ add , 10 , 97 }} . Note that this is not the server reply. To obtain the server reply from the mailbox of the shell, we use another BIF , flush / 0 , that empties the mailbox contents on the shell. 4> flush (). Shell got {ok,107} ok Sending a multiplication request is similar to adding two numbers: 5> Pid ! { self (), { mul , 10 , 97 }}. {<0.84.0>,{mul,10,97}} 6> flush (). Shell got {ok,970} ok To shutdown the server, we issue a stp request. 7> Pid ! { self (), stp }. {<0.84.0>,stp} 8> flush (). Shell got {bye,2} ok 9> is_process_alive ( Pid ). false Before terminating, our server replies to the sender with { bye , 2 } , that contains the total number of requests serviced, add and mul in our example. The shell excerpt also confirms that the server process is terminated. We note that at this point, the server PID value < 0 . 84 . 0 > is still instantiated in the variable Pid, which is now stale. Sending a message to a non-existing PID via ! is silently ignored without raising any errors. Our buggy implementation of the server in the calc_server_bug module operates exactly to the correct version, and can be launched by following the steps above. Inline instrumentation in action \u00b6 Since in the previous section we executed make that cleans the ebin directory, we have to once more synthesise our analyser. 10> hml_eval : compile ( \"props/prop_add_rec.hml\" , [{ outdir , \"ebin\" }, v ]). ok Now we can instrument the server we want analysed. detectEr provides the weaver module that offers two functions, weave_file / 3 that weaves a single file, and weave / 3 that weaves an entire directory of files. We will use weave / 3 to weave both the correct and buggy implementation of our calculator server. The two variants of weave accept three arguments: the file where the Erlang source file to be weaved resides (or directory of files, in case of weave / 3 ), the function mfa_spec / 1 of the analyser we want weaved, and, an option list. The options supported by weave_file / 3 and weaver / 3 are as follows: Option Description outdir Directory where the generated weaved files should be written. If left unspecified, defaults to the current directory . . i Directory containing include files that the source files in the source directory depend on. filter Filter function that suppresses events. If left unspecified, defaults to \u2018allows any\u2019. erl Instructs the compiler to output the generated files as Erlang source code rather than beam . If left unspecified, defaults to beam . For this demo, we use the buggy version of our calculator server to detect property violations. Weave the src/demo directory by executing: 11> weaver : weave ( \"src/demo\" , fun prop_add_rec : mfa_spec / 1 , [{ outdir , \"ebin\" }]). [{ok,calc_client,[]}, {ok,calc_server,[]}, {ok,calc_server_bug,[]}, {ok,hello,[]}] The weaved files will be automatically loaded for you in the shell. Next, launch the buggy server. We will use the same variable Pid to keep hold of the PID returned by calc_server_bug:start/1 . Since Erlang does not allow variables to be assigned more than once, we have to free the variable Pid before reusing it. We do this using the f/1 BIF . 12> f ( Pid ). ok 13> Pid = calc_server_bug : start ( 0 ). *** [<0.84.0>] Instrumenting monitor for MFA pattern '{calc_server_bug,loop,[0]}'. *** [<0.141.0>] Analyzing event {trace,<0.141.0>,spawned,<0.84.0>,{calc_server_bug,loop,[0]}}. <0.141.0> As soon as the calculator server process starts, the analyser immediately enters into action and analyses the first process event init . Here we see this as the internal Erlang spawned event (see From specification to analyser ). Now, let us try an addition request. 14> Pid ! { self (), { add , 10 , 97 }}. *** [<0.141.0>] Analyzing event {trace,<0.141.0>,'receive',{<0.84.0>,{add,10,97}}}. {<0.84.0>,{add,10,97}} *** [<0.141.0>] Analyzing event {trace,<0.141.0>,send,{ok,-87},<0.84.0>}. *** [<0.141.0>] Reached verdict 'no'. As expected, this leads to a rejection verdict, no , that corresponds to a violation of our property P 3 . Stop the server. 15> Pid ! { self (), stp }. [INFO - <0.141.0> - analyzer:179] - Reached verdict 'no' after {recv,<0.141.0>,{<0.84.0>,stp}}. [INFO - <0.141.0> - analyzer:174] - Reached verdict 'no' after {send,<0.141.0>,<0.84.0>,{bye,1}}. {<0.84.0>,stp} Irrevocable verdicts \u00b6 You might have noticed that the recv and send events exhibited by the calculator server process as it terminated (step 4 above) are also analysed by our analyser. Both of these analyses yield the same rejection verdict of no . Why does this happen? In the section Is one execution trace enough? we explained that analysers yield irrevocable verdicts ( i.e. , ones that cannot be retracted). This is one such instance, where the verdict no is flagged, and the analyser will persist its decision, regardless of the events it analyses going forward. Testing the correct server implementation \u00b6 Try running the correct version of the server, following steps 2-4 above. Launch the instrumented server. 16> f ( Pid ). Pid = calc_server:start(0). *** [<0.84.0>] Instrumenting monitor for MFA pattern '{calc_server,loop,[0]}'. *** [<0.146.0>] Analyzing event {trace,<0.146.0>,spawned,<0.84.0>,{calc_server,loop,[0]}}. <0.146.0> Perform an addition request. 17> Pid ! { self (), { add , 10 , 97 }}. *** [<0.146.0>] Analyzing event {trace,<0.146.0>,'receive',{<0.84.0>,{add,10,97}}}. {<0.84.0>,{add,10,97}} *** [<0.146.0>] Analyzing event {trace,<0.146.0>,send,{ok,107},<0.84.0>}. *** [<0.146.0>] Unfolding rec. var. 'X'. In this case where the addition is correctly executed by the server, the analyser unfolds the recursion via the variable X , and resumes its analysis. Try submitting a multiplication request. 18> Pid ! { self (), { mul , 10 , 97 }}. *** [<0.146.0>] Reached verdict 'end' on event {trace,<0.146.0>,'receive',{<0.84.0>,{mul,10,97}}}. {<0.84.0>,{mul,10,97}} The analyser reaches the inconclusive verdict end since given the event { trace , < 0 . 146 . 0 > , 'receive' ,{ < 0 . 84 . 0 > ,{ mul , 10 , 97 }}} , it cannot determine whether these will eventually lead to a violation. Furthermore, now that the analyser has reached this point of inconclusiveness, it cannot backtrack, and will always yield the verdict end for every subsequent event it analyses. This is another instance of verdict irrevocability. Stopping the server elicits the same behaviour from the analyser. Pid ! {self(), stp}. [INFO - <0.146.0> - analyzer:179] - Reached verdict 'end' after {recv,<0.146.0>,{<0.84.0>,stp}}. [INFO - <0.146.0> - analyzer:174] - Reached verdict 'end' after {send,<0.146.0>,<0.84.0>,{bye,2}}. {<0.84.0>,stp} The next instrumentation method, outlining, completely externalises the instrumentation and analysis, and does not assume access to the program source code, as inlining does.","title":"Inline Instrumentation"},{"location":"using-detecter/inline-instrumentation.html#inline-instrumentation","text":"","title":"Inline Instrumentation"},{"location":"using-detecter/inline-instrumentation.html#overview","text":"Inlining is the most efficient instrumentation approach detectEr offers. While it assumes access to the program source code, it carries benefits such as low runtime overhead and immediate detections. There are various other RV tools, especially those targeting the JVM, that adopt inlining as their instrumentation method of choice, using libraries such as AspectJ and ASM . One drawback of inlining is that it tends to be invasive, and cannot be used in scenarios where the program code is not available ( e.g. compiled versions of the program, licensing agreements, etc. ). detectEr employs a custom-built weaver to instrument invocations to analysers via code injection, by manipulating the program abstract syntax tree. This procedure is detailed in the companion paper ; readers are encouraged to consult this resource for more details. Here, we will learn how to use detectEr to inline and analyse programs for which the source code is available. Once more, we rely on our Erlang implementation of the calculator server from the Getting Started section to show how this is done.","title":"Overview"},{"location":"using-detecter/inline-instrumentation.html#the-calculator-server-program","text":"Let us run the calculator server program with no instrumentation applied, to familiarise ourselves with its basic operation. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to examples/erlang . [duncan@local]:/detecter$ cd examples/erlang [duncan@local]:/detecter/examples/erlang$ ls -l -rw-rw-r-- 1 duncan duncan 996 May 17 17:16 Makefile drwxrwxr-x 2 duncan duncan 4096 May 17 17:16 props drwxrwxr-x 3 duncan duncan 4096 May 17 17:16 src Execute make to compile all of the Erlang source code modules located in examples/erlang/src . A new ebin directory containing the compiled *.beam files is created. Launch the Erlang shell erl . We add the detectEr binaries and the ones we have just compiled to the shell code path via -pa . [duncan@local]:/detecter/examples/erlang$ erl -pa ../../detecter/ebin ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> The calculator server is started by invoking calc_server : start / 1 . If you recall from the section Getting Started , start / 1 accepts a single argument N that it uses to track the number of requests handled. Function start / 1 spawns the server process and returns its PID . We need to hold on to this PID in order to use it to communicate with our server. To do this, we store the PID in the variable Pid . 1> Pid = calc_server : start ( 0 ). <0.86.0> We can check that the server process has actually started using the is_process_alive/1 BIF . 2> is_process_alive ( Pid ). true The server is now ready to handle client requests. Messages in Erlang are submitted using the send operator, ! , that takes the PID of the recipient process and the message to send as arguments. The data in the request message we send must coincide with one of the clauses that the server is able to pattern match in its receive expression. When this is not the case, the message is not processed, and left queued in the calculator server mailbox. Try instructing the server to add two numbers, 10 and 97 . 3> Pid ! { self (), { add , 10 , 97 }}. {<0.84.0>,{add,10,97}} Let us dissect our request message. It consists of the pair containing the PID of the Erlang shell, which we obtain through the BIF self / 0 , and the payload, { add , 10 , 97 } . Send expressions in Erlang evaluate to the message sent, which is why the shell prints the output { < 0 . 84 . 0 > ,{ add , 10 , 97 }} . Note that this is not the server reply. To obtain the server reply from the mailbox of the shell, we use another BIF , flush / 0 , that empties the mailbox contents on the shell. 4> flush (). Shell got {ok,107} ok Sending a multiplication request is similar to adding two numbers: 5> Pid ! { self (), { mul , 10 , 97 }}. {<0.84.0>,{mul,10,97}} 6> flush (). Shell got {ok,970} ok To shutdown the server, we issue a stp request. 7> Pid ! { self (), stp }. {<0.84.0>,stp} 8> flush (). Shell got {bye,2} ok 9> is_process_alive ( Pid ). false Before terminating, our server replies to the sender with { bye , 2 } , that contains the total number of requests serviced, add and mul in our example. The shell excerpt also confirms that the server process is terminated. We note that at this point, the server PID value < 0 . 84 . 0 > is still instantiated in the variable Pid, which is now stale. Sending a message to a non-existing PID via ! is silently ignored without raising any errors. Our buggy implementation of the server in the calc_server_bug module operates exactly to the correct version, and can be launched by following the steps above.","title":"The calculator server program"},{"location":"using-detecter/inline-instrumentation.html#inline-instrumentation-in-action","text":"Since in the previous section we executed make that cleans the ebin directory, we have to once more synthesise our analyser. 10> hml_eval : compile ( \"props/prop_add_rec.hml\" , [{ outdir , \"ebin\" }, v ]). ok Now we can instrument the server we want analysed. detectEr provides the weaver module that offers two functions, weave_file / 3 that weaves a single file, and weave / 3 that weaves an entire directory of files. We will use weave / 3 to weave both the correct and buggy implementation of our calculator server. The two variants of weave accept three arguments: the file where the Erlang source file to be weaved resides (or directory of files, in case of weave / 3 ), the function mfa_spec / 1 of the analyser we want weaved, and, an option list. The options supported by weave_file / 3 and weaver / 3 are as follows: Option Description outdir Directory where the generated weaved files should be written. If left unspecified, defaults to the current directory . . i Directory containing include files that the source files in the source directory depend on. filter Filter function that suppresses events. If left unspecified, defaults to \u2018allows any\u2019. erl Instructs the compiler to output the generated files as Erlang source code rather than beam . If left unspecified, defaults to beam . For this demo, we use the buggy version of our calculator server to detect property violations. Weave the src/demo directory by executing: 11> weaver : weave ( \"src/demo\" , fun prop_add_rec : mfa_spec / 1 , [{ outdir , \"ebin\" }]). [{ok,calc_client,[]}, {ok,calc_server,[]}, {ok,calc_server_bug,[]}, {ok,hello,[]}] The weaved files will be automatically loaded for you in the shell. Next, launch the buggy server. We will use the same variable Pid to keep hold of the PID returned by calc_server_bug:start/1 . Since Erlang does not allow variables to be assigned more than once, we have to free the variable Pid before reusing it. We do this using the f/1 BIF . 12> f ( Pid ). ok 13> Pid = calc_server_bug : start ( 0 ). *** [<0.84.0>] Instrumenting monitor for MFA pattern '{calc_server_bug,loop,[0]}'. *** [<0.141.0>] Analyzing event {trace,<0.141.0>,spawned,<0.84.0>,{calc_server_bug,loop,[0]}}. <0.141.0> As soon as the calculator server process starts, the analyser immediately enters into action and analyses the first process event init . Here we see this as the internal Erlang spawned event (see From specification to analyser ). Now, let us try an addition request. 14> Pid ! { self (), { add , 10 , 97 }}. *** [<0.141.0>] Analyzing event {trace,<0.141.0>,'receive',{<0.84.0>,{add,10,97}}}. {<0.84.0>,{add,10,97}} *** [<0.141.0>] Analyzing event {trace,<0.141.0>,send,{ok,-87},<0.84.0>}. *** [<0.141.0>] Reached verdict 'no'. As expected, this leads to a rejection verdict, no , that corresponds to a violation of our property P 3 . Stop the server. 15> Pid ! { self (), stp }. [INFO - <0.141.0> - analyzer:179] - Reached verdict 'no' after {recv,<0.141.0>,{<0.84.0>,stp}}. [INFO - <0.141.0> - analyzer:174] - Reached verdict 'no' after {send,<0.141.0>,<0.84.0>,{bye,1}}. {<0.84.0>,stp}","title":"Inline instrumentation in action"},{"location":"using-detecter/inline-instrumentation.html#irrevocable-verdicts","text":"You might have noticed that the recv and send events exhibited by the calculator server process as it terminated (step 4 above) are also analysed by our analyser. Both of these analyses yield the same rejection verdict of no . Why does this happen? In the section Is one execution trace enough? we explained that analysers yield irrevocable verdicts ( i.e. , ones that cannot be retracted). This is one such instance, where the verdict no is flagged, and the analyser will persist its decision, regardless of the events it analyses going forward.","title":"Irrevocable verdicts"},{"location":"using-detecter/inline-instrumentation.html#testing-the-correct-server-implementation","text":"Try running the correct version of the server, following steps 2-4 above. Launch the instrumented server. 16> f ( Pid ). Pid = calc_server:start(0). *** [<0.84.0>] Instrumenting monitor for MFA pattern '{calc_server,loop,[0]}'. *** [<0.146.0>] Analyzing event {trace,<0.146.0>,spawned,<0.84.0>,{calc_server,loop,[0]}}. <0.146.0> Perform an addition request. 17> Pid ! { self (), { add , 10 , 97 }}. *** [<0.146.0>] Analyzing event {trace,<0.146.0>,'receive',{<0.84.0>,{add,10,97}}}. {<0.84.0>,{add,10,97}} *** [<0.146.0>] Analyzing event {trace,<0.146.0>,send,{ok,107},<0.84.0>}. *** [<0.146.0>] Unfolding rec. var. 'X'. In this case where the addition is correctly executed by the server, the analyser unfolds the recursion via the variable X , and resumes its analysis. Try submitting a multiplication request. 18> Pid ! { self (), { mul , 10 , 97 }}. *** [<0.146.0>] Reached verdict 'end' on event {trace,<0.146.0>,'receive',{<0.84.0>,{mul,10,97}}}. {<0.84.0>,{mul,10,97}} The analyser reaches the inconclusive verdict end since given the event { trace , < 0 . 146 . 0 > , 'receive' ,{ < 0 . 84 . 0 > ,{ mul , 10 , 97 }}} , it cannot determine whether these will eventually lead to a violation. Furthermore, now that the analyser has reached this point of inconclusiveness, it cannot backtrack, and will always yield the verdict end for every subsequent event it analyses. This is another instance of verdict irrevocability. Stopping the server elicits the same behaviour from the analyser. Pid ! {self(), stp}. [INFO - <0.146.0> - analyzer:179] - Reached verdict 'end' after {recv,<0.146.0>,{<0.84.0>,stp}}. [INFO - <0.146.0> - analyzer:174] - Reached verdict 'end' after {send,<0.146.0>,<0.84.0>,{bye,2}}. {<0.84.0>,stp} The next instrumentation method, outlining, completely externalises the instrumentation and analysis, and does not assume access to the program source code, as inlining does.","title":"Testing the correct server implementation"},{"location":"using-detecter/instrumentation.html","text":"Instrumentation \u00b6 Grey and black box approaches \u00b6 Instrumentation is the second ingredient that lies at the heart of runtime monitoring. It refers to the extraction of information from executing software, following one of two approaches. In the grey box approach, instrumentation is implemented by weaving instructions that extract information, directly into the program under scrutiny. Alternatively, instrumentation can leverage an existing tracing infrastructure to collect information externally. In this manner, the program we want to observe is treated as a black box . As you might have guessed, the kind of information that we want extracted from programs is the sequence of events, i.e. , the execution trace. Besides extracting the trace, the instrumentation reports the events to the analysis that then processes them to reach the monitoring verdicts we introduced previously . detectEr implements three instrumentation methods: inline , outline , and offline instrumentation. Inline instrumentation, adopts the weaving approach, and is therefore the more invasive of the three. Outlining makes use of the native tracing infrastructure provided by the EVM , whereas offline instrumentation emulates this tracing set-up via the use of log files that act as a trace storage that can be replayed. detectEr preserves the separation of concerns that exists between the analysis and instrumentation. Indeed, the analysers that we generate via the function hml_eval : compile / 2 can be readily used with any of the three instrumentation approaches, unless of course, the targeted function spawning processes differs. Now we detail how these may be used via three different implementations of our calculator server example, starting with the inline approach.","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#instrumentation","text":"","title":"Instrumentation"},{"location":"using-detecter/instrumentation.html#grey-and-black-box-approaches","text":"Instrumentation is the second ingredient that lies at the heart of runtime monitoring. It refers to the extraction of information from executing software, following one of two approaches. In the grey box approach, instrumentation is implemented by weaving instructions that extract information, directly into the program under scrutiny. Alternatively, instrumentation can leverage an existing tracing infrastructure to collect information externally. In this manner, the program we want to observe is treated as a black box . As you might have guessed, the kind of information that we want extracted from programs is the sequence of events, i.e. , the execution trace. Besides extracting the trace, the instrumentation reports the events to the analysis that then processes them to reach the monitoring verdicts we introduced previously . detectEr implements three instrumentation methods: inline , outline , and offline instrumentation. Inline instrumentation, adopts the weaving approach, and is therefore the more invasive of the three. Outlining makes use of the native tracing infrastructure provided by the EVM , whereas offline instrumentation emulates this tracing set-up via the use of log files that act as a trace storage that can be replayed. detectEr preserves the separation of concerns that exists between the analysis and instrumentation. Indeed, the analysers that we generate via the function hml_eval : compile / 2 can be readily used with any of the three instrumentation approaches, unless of course, the targeted function spawning processes differs. Now we detail how these may be used via three different implementations of our calculator server example, starting with the inline approach.","title":"Grey and black box approaches"},{"location":"using-detecter/offline-instrumentation.html","text":"Offline Instrumentation \u00b6 Overview \u00b6 The notion of outline instrumentation is extended to the offline case where the program potentially runs outside of the EVM . detectEr implements a middleware component that emulates the EVM tracing infrastructure. The enables detectEr to employ the same outline instrumentation algorithm we use in Outline Instrumentation for offline instrumentation too. Offline set-ups are generally the slowest in terms of verdict detection, by comparison to the inline and outline forms of instrumentation. This stems from the dependence outline instrumentation has on the timely availability of pre-recorded runtime traces that are subject to external software entities, such as, files. Our outline instrumentation middleware logic is encapsulated in the log_tracer module that exposes a trace / 1 function to dynamically attach to processes. The log_tracer module relies on log files at the medium through which programs can communicate trace events to the offline set-up. detectEr can process plain text log files containing complete program runs, or actively monitor files for changes to dynamically dispatch events to analysers while the program is executing and updating the log file. Of course, the log file in question must be known to both the program that writes to it and the log_tracer module reading events. Offline instrumentation supports the five events fork , init , exit , send , and recv , but assumes that event entries in log files are written in a pre-determined format recognisable by detectEr. Events must be written one per line , structured as described in the table below. Program event Event entry pattern Entry variable Description fork fork(P\u2081, P\u2082, {Mod, Fun, Args}) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 {Mod, Fun, Args} Function signature consisting of the module, function and arguments init init(P\u2082, P\u2081, {Mod, Fun, Args}) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 {Mod, Fun, Args} Function signature consisting of the module, function and arguments exit exit(P\u2081, Reason) P\u2081 PID of the terminated process Reason Termination reason send send(P\u2081, P\u2082, Msg) P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv recv(P\u2082, Msg) P\u2082 PID of the recipient process Msg Message payload The calculator server program \u00b6 To demonstrate outline instrumentation, we once more use a buggy version of our calculator server that subtracts numbers, rather than adding them. This Python implementation operates similar to the Erlang and Elixir analogues, but messages are exchanged in plain text over TCP sockets. The buggy and correct server implementations may be found in the examples/python directory. Both versions of this server expose the function start () that accepts the argument n . start () launches a thread that initialises and binds to a socket, and then repeatedly listens for incoming client connections on port 8080 . This server loop mirrors the operation of our Erlang and Elixir implementations seen earlier. Its communication protocol is, however, adapted slightly to suit the TCP setting. In order for us to use offline instrumentation, the server needs to communicate its events externally. This, it does by writing events using the standard Python logging facility in a user-specified log file. The Python module provides a command line interface that launches the function start () . This CLI accepts two arguments, n , the request count to start the server with, and log , the file path of the log file where program events are written. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to example/python : [duncan@local]:/detecter$ cd examples/python [duncan@local]:/detecter/examples/python$ ls -l -rw-r--r-- 1 duncan duncan 1197 Jun 14 09:22 Makefile drwxr-xr-x 4 duncan duncan 128 Jun 14 09:22 props drwxr-xr-x 3 duncan duncan 96 Jun 14 09:22 src For the case of Python, we need to create a new virtual environment where all our dependencies can be installed in a sandbox that does not affect the global Python installation on your system. We do this via the virtualenv tool. If you have not already installed virtualenv for Python 3, follow the instructions in the Installing the virtual environment management tool section. [duncan@local]:/detecter/examples/python$ virtualenv venv created virtual environment CPython3.9.4.final.0-64 in 1230ms ... Next, we launch the virtual environment, change directory to src , and start the server. The server is started with a n value of 0 , and set to write logs to the file /detecter/examples/python/trace.log . [duncan@local]:/detecter/examples/python$ source venv/bin/activate [duncan@local]:/detecter/examples/python (venv)$ cd src [duncan@local]:/examples/python/src (venv)$ python -m demo.calc_server_bug 0 ../trace.log Started server on 0.0.0.0:8080.. Now that that server is bound to port 8080 on localhost , it is ready to accept TCP requests. Communication with the server can be established via telnet . Launch a new terminal emulator window, and type: [duncan@local]:/detecter/examples/python telnet localhost 8080 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. The server terminal window should indicate that a client is connected, displaying a message similar to \u2018Connected by 127.0.0.1:58576\u2019. The calculator server communication protocol is text-based. Request operations start with a forward slash / , followed by the operation name ( e.g. , add ) and its arguments, separated by spaces. Every command is terminated with a carriage return. Let us try performing an addition request from the telnet CLI by typing: /add 10 97 -87.0 We get the incorrect result of addition as expected. On the server terminal window, you should be able to see the output: Received command /add 10.0 97.0. Having started the server and issued a first request, we are now in a position to examine the events that our Python server writes to trace.log . We can actively monitor this file from the terminal via the tail utility. Launch a third terminal emulator window, make sure you are in examples/python , and tail trace.log : [duncan@local]:/detecter/examples/python tail -f trace.log fork(<0.102.0>,<0.808.0>,{calc_server_bug,loop,[0]}) exit(<0.102.0>,normal) init(<0.808.0>,<0.102.0>,{calc_server_bug,loop,[0]}) recv(<0.808.0>,{<0.585.0>,{add,10.0,97.0}}) send(<0.808.0>,<0.585.0>,{ok,-87.0}) These events describe the server operation up until this point. For instance, fork(<0.102.0>,<0.808.0>,{calc_server_bug,loop,[0]}) indicates that the main thread that invokes the function start () launches calc_server_bug . loop ( n ) as a thread with n = 0 . Once this operation is completed, the main thread terminates, exit(<0.102.0>,normal) . Meanwhile, the calculator server thread exhibits the init event, subsequent to which, produces the recv and send program events following our /add 10 97 request issued from the telnet CLI . Here, <0.102.0> is the PID of the main thread invoking start () , and <0.808.0> , the PID of the server process. Keeping the tail window open, try issuing a multiplication request to the server: /mul 10 97 970.0 You should see the recv and send events written to trace.log. recv(<0.808.0>,{<0.585.0>,{mul,10.0,97.0}}) send(<0.808.0>,<0.585.0>,{ok,970.0}) We can stop the server by issuing a stop request using telnet : /stp stopped Connection closed by foreign host. The corresponding server interaction and termination events are written to trace.log . recv(<0.808.0>,{<0.585.0>,stp}) send(<0.808.0>,<0.585.0>,{bye,0}) exit(<0.808.0>,normal) The correct implementation of the server in the calc_server Python module can be launched following the steps above. Offline instrumentation in action \u00b6 Since the sHML specifications in the script used for our inline instrumentation demo target the same function names calc_server_bug : loop / 1 and calc_server : loop / 1 , we need not regenerate the respective analysers. Close tail by pressing Ctrl + C . Create a new directory ebin inside examples/python , and copy the file examples/erlang/ebin/prop_add_rec.beam to it. [duncan@local]:/detecter/examples/python (venv)$ mkdir ebin [duncan@local]:/detecter/examples/python (venv)$ cp ../erlang/ebin/prop_add_rec.beam ebin [duncan@local]:/detecter/examples/python (venv)$ ls -l ebin -rw-r--r-- 1 duncan duncan 2748 Jun 14 10:52 prop_add_rec.beam To monitor log files, detectEr employs a concept similar to the tail utility we have just used. Offline instrumentation is launched using module : start_offline / 4 , that accepts four arguments: the path of the log file where events are written (the log file need not necessarily exist; it will be automatically opened for parsing when created), the PID of the root program process, the function mfa_spec / 1 of the analyser we want to use, an option list. The options supported by monitor : start_offline / 4 are identical to those of monitor : start_online / 3 . Let us set up outline instrumentation. Make sure you are in the directory /detecter/examples/python . Delete trace.log : [duncan@local]:/detecter/examples/python$ rm trace.log Launch a new Erlang shell, adding the detectEr binaries and the ebin directory containing the copied prop_add_rec.beam : [duncan@local]:/detecter/examples/python$ erl -pa ../../detecter/ebin ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Start offline instrumentation by invoking start_offline / 4 . The first argument points to our yet-to-be-created trace.log file, the second is the PID of the root program process, third comes the analyser module, and finally, the list of options, which we leave empty. The root PID is required to bootstrap outline instrumentation. Recall that in our specific case, this is the PID of main thread that invokes the function start () . We convert the PID manually from the constituent component parts 0 , 102 , 0 to an Erlang PID using the BIF pid / 3 . 1> monitor : start_offline ( \"trace.log\" , pid ( 0 , 102 , 0 ), fun prop_add_rec : mfa_spec / 1 , []). init_it: Starter=<0.84.0>, Parent=<0.84.0>, Name={local,log_poller}, Mod=log_poller, Args=[\"trace.log\"], Opts=[] <0.86.0> Launch the buggy calculator server from a separate terminal emulator window, as done previously. [duncan@local]:/examples/python/src (venv)$ python -m demo.calc_server_bug 0 ../trace.log Started server on 0.0.0.0:8080.. detectEr automatically registers the creation of trace.log and starts analysing events right away. It instruments the analyser and promptly analyses the first process event, init . This is translated to the internal Erlang spawned event (see From specification to analyser ). *** [<0.86.0>] Instrumenting monitor for MFA pattern '{calc_server_bug,loop,[0]}'. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,spawned,<0.102.0>,{calc_server_bug,loop,[0]}}. Let us submit an addition request through telnet . [duncan@local]:/detecter/examples/python$ telnet localhost 8080 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. /add 10 97 -87.0 The Erlang shell hosting detectEr shows that this leads to the rejection verdict no , corresponding to a violation of property P 3 . *** [<0.89.0>] Analyzing event {trace,<0.808.0>,'receive',{<0.610.0>,{add,10.0,97.0}}}. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,send,{ok,-87.0},<0.610.0>}. *** [<0.89.0>] Reached verdict 'no'. Stop the server: /stp stopped Connection closed by foreign host. Stop the outline instrumentation. We need to do this since the log is read in a forward-only manner, and rewriting to it disrupts the parsing mechanism. monitor:stop(). The output on the Erlang shell is the same as the one we have seen previously with outline instrumentation, where analysers are terminated promptly upon verdict detection. Testing the correct server implementation \u00b6 Go ahead and test the correct calculator server implementation, calc_server , following the above steps. Remember to remove trace.log prior to starting detectEr in offline mode, otherwise it will process the events from our previous run. When executing /add requests, you should be able to see the offline analyser recurse via variable X . 1> monitor : start_offline ( \"trace.log\" , pid ( 0 , 102 , 0 ), fun prop_add_rec : mfa_spec / 1 , []). init_it: Starter=<0.84.0>, Parent=<0.84.0>, Name={local,log_poller}, Mod=log_poller, Args=[\"trace.log\"], Opts=[] <0.86.0> *** [<0.86.0>] Instrumenting monitor for MFA pattern '{calc_server,loop,[0]}'. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,spawned,<0.102.0>,{calc_server,loop,[0]}}. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,'receive',{<0.612.0>,{add,10.0,97.0}}}. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,send,{ok,107.0},<0.612.0>}. *** [<0.89.0>] Unfolding rec. var. 'X'. Issuing both /mul and /stp requests leads to the inconclusive verdict end . *** [<0.89.0>] Reached verdict 'end' on event {trace,<0.808.0>,'receive',{<0.612.0>,{mul,10.0,97.0}}}. Congratulations on completing this tutorial! Woohoo!","title":"Offline Instrumentation"},{"location":"using-detecter/offline-instrumentation.html#offline-instrumentation","text":"","title":"Offline Instrumentation"},{"location":"using-detecter/offline-instrumentation.html#overview","text":"The notion of outline instrumentation is extended to the offline case where the program potentially runs outside of the EVM . detectEr implements a middleware component that emulates the EVM tracing infrastructure. The enables detectEr to employ the same outline instrumentation algorithm we use in Outline Instrumentation for offline instrumentation too. Offline set-ups are generally the slowest in terms of verdict detection, by comparison to the inline and outline forms of instrumentation. This stems from the dependence outline instrumentation has on the timely availability of pre-recorded runtime traces that are subject to external software entities, such as, files. Our outline instrumentation middleware logic is encapsulated in the log_tracer module that exposes a trace / 1 function to dynamically attach to processes. The log_tracer module relies on log files at the medium through which programs can communicate trace events to the offline set-up. detectEr can process plain text log files containing complete program runs, or actively monitor files for changes to dynamically dispatch events to analysers while the program is executing and updating the log file. Of course, the log file in question must be known to both the program that writes to it and the log_tracer module reading events. Offline instrumentation supports the five events fork , init , exit , send , and recv , but assumes that event entries in log files are written in a pre-determined format recognisable by detectEr. Events must be written one per line , structured as described in the table below. Program event Event entry pattern Entry variable Description fork fork(P\u2081, P\u2082, {Mod, Fun, Args}) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 {Mod, Fun, Args} Function signature consisting of the module, function and arguments init init(P\u2082, P\u2081, {Mod, Fun, Args}) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 {Mod, Fun, Args} Function signature consisting of the module, function and arguments exit exit(P\u2081, Reason) P\u2081 PID of the terminated process Reason Termination reason send send(P\u2081, P\u2082, Msg) P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv recv(P\u2082, Msg) P\u2082 PID of the recipient process Msg Message payload","title":"Overview"},{"location":"using-detecter/offline-instrumentation.html#the-calculator-server-program","text":"To demonstrate outline instrumentation, we once more use a buggy version of our calculator server that subtracts numbers, rather than adding them. This Python implementation operates similar to the Erlang and Elixir analogues, but messages are exchanged in plain text over TCP sockets. The buggy and correct server implementations may be found in the examples/python directory. Both versions of this server expose the function start () that accepts the argument n . start () launches a thread that initialises and binds to a socket, and then repeatedly listens for incoming client connections on port 8080 . This server loop mirrors the operation of our Erlang and Elixir implementations seen earlier. Its communication protocol is, however, adapted slightly to suit the TCP setting. In order for us to use offline instrumentation, the server needs to communicate its events externally. This, it does by writing events using the standard Python logging facility in a user-specified log file. The Python module provides a command line interface that launches the function start () . This CLI accepts two arguments, n , the request count to start the server with, and log , the file path of the log file where program events are written. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to example/python : [duncan@local]:/detecter$ cd examples/python [duncan@local]:/detecter/examples/python$ ls -l -rw-r--r-- 1 duncan duncan 1197 Jun 14 09:22 Makefile drwxr-xr-x 4 duncan duncan 128 Jun 14 09:22 props drwxr-xr-x 3 duncan duncan 96 Jun 14 09:22 src For the case of Python, we need to create a new virtual environment where all our dependencies can be installed in a sandbox that does not affect the global Python installation on your system. We do this via the virtualenv tool. If you have not already installed virtualenv for Python 3, follow the instructions in the Installing the virtual environment management tool section. [duncan@local]:/detecter/examples/python$ virtualenv venv created virtual environment CPython3.9.4.final.0-64 in 1230ms ... Next, we launch the virtual environment, change directory to src , and start the server. The server is started with a n value of 0 , and set to write logs to the file /detecter/examples/python/trace.log . [duncan@local]:/detecter/examples/python$ source venv/bin/activate [duncan@local]:/detecter/examples/python (venv)$ cd src [duncan@local]:/examples/python/src (venv)$ python -m demo.calc_server_bug 0 ../trace.log Started server on 0.0.0.0:8080.. Now that that server is bound to port 8080 on localhost , it is ready to accept TCP requests. Communication with the server can be established via telnet . Launch a new terminal emulator window, and type: [duncan@local]:/detecter/examples/python telnet localhost 8080 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. The server terminal window should indicate that a client is connected, displaying a message similar to \u2018Connected by 127.0.0.1:58576\u2019. The calculator server communication protocol is text-based. Request operations start with a forward slash / , followed by the operation name ( e.g. , add ) and its arguments, separated by spaces. Every command is terminated with a carriage return. Let us try performing an addition request from the telnet CLI by typing: /add 10 97 -87.0 We get the incorrect result of addition as expected. On the server terminal window, you should be able to see the output: Received command /add 10.0 97.0. Having started the server and issued a first request, we are now in a position to examine the events that our Python server writes to trace.log . We can actively monitor this file from the terminal via the tail utility. Launch a third terminal emulator window, make sure you are in examples/python , and tail trace.log : [duncan@local]:/detecter/examples/python tail -f trace.log fork(<0.102.0>,<0.808.0>,{calc_server_bug,loop,[0]}) exit(<0.102.0>,normal) init(<0.808.0>,<0.102.0>,{calc_server_bug,loop,[0]}) recv(<0.808.0>,{<0.585.0>,{add,10.0,97.0}}) send(<0.808.0>,<0.585.0>,{ok,-87.0}) These events describe the server operation up until this point. For instance, fork(<0.102.0>,<0.808.0>,{calc_server_bug,loop,[0]}) indicates that the main thread that invokes the function start () launches calc_server_bug . loop ( n ) as a thread with n = 0 . Once this operation is completed, the main thread terminates, exit(<0.102.0>,normal) . Meanwhile, the calculator server thread exhibits the init event, subsequent to which, produces the recv and send program events following our /add 10 97 request issued from the telnet CLI . Here, <0.102.0> is the PID of the main thread invoking start () , and <0.808.0> , the PID of the server process. Keeping the tail window open, try issuing a multiplication request to the server: /mul 10 97 970.0 You should see the recv and send events written to trace.log. recv(<0.808.0>,{<0.585.0>,{mul,10.0,97.0}}) send(<0.808.0>,<0.585.0>,{ok,970.0}) We can stop the server by issuing a stop request using telnet : /stp stopped Connection closed by foreign host. The corresponding server interaction and termination events are written to trace.log . recv(<0.808.0>,{<0.585.0>,stp}) send(<0.808.0>,<0.585.0>,{bye,0}) exit(<0.808.0>,normal) The correct implementation of the server in the calc_server Python module can be launched following the steps above.","title":"The calculator server program"},{"location":"using-detecter/offline-instrumentation.html#offline-instrumentation-in-action","text":"Since the sHML specifications in the script used for our inline instrumentation demo target the same function names calc_server_bug : loop / 1 and calc_server : loop / 1 , we need not regenerate the respective analysers. Close tail by pressing Ctrl + C . Create a new directory ebin inside examples/python , and copy the file examples/erlang/ebin/prop_add_rec.beam to it. [duncan@local]:/detecter/examples/python (venv)$ mkdir ebin [duncan@local]:/detecter/examples/python (venv)$ cp ../erlang/ebin/prop_add_rec.beam ebin [duncan@local]:/detecter/examples/python (venv)$ ls -l ebin -rw-r--r-- 1 duncan duncan 2748 Jun 14 10:52 prop_add_rec.beam To monitor log files, detectEr employs a concept similar to the tail utility we have just used. Offline instrumentation is launched using module : start_offline / 4 , that accepts four arguments: the path of the log file where events are written (the log file need not necessarily exist; it will be automatically opened for parsing when created), the PID of the root program process, the function mfa_spec / 1 of the analyser we want to use, an option list. The options supported by monitor : start_offline / 4 are identical to those of monitor : start_online / 3 . Let us set up outline instrumentation. Make sure you are in the directory /detecter/examples/python . Delete trace.log : [duncan@local]:/detecter/examples/python$ rm trace.log Launch a new Erlang shell, adding the detectEr binaries and the ebin directory containing the copied prop_add_rec.beam : [duncan@local]:/detecter/examples/python$ erl -pa ../../detecter/ebin ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> Start offline instrumentation by invoking start_offline / 4 . The first argument points to our yet-to-be-created trace.log file, the second is the PID of the root program process, third comes the analyser module, and finally, the list of options, which we leave empty. The root PID is required to bootstrap outline instrumentation. Recall that in our specific case, this is the PID of main thread that invokes the function start () . We convert the PID manually from the constituent component parts 0 , 102 , 0 to an Erlang PID using the BIF pid / 3 . 1> monitor : start_offline ( \"trace.log\" , pid ( 0 , 102 , 0 ), fun prop_add_rec : mfa_spec / 1 , []). init_it: Starter=<0.84.0>, Parent=<0.84.0>, Name={local,log_poller}, Mod=log_poller, Args=[\"trace.log\"], Opts=[] <0.86.0> Launch the buggy calculator server from a separate terminal emulator window, as done previously. [duncan@local]:/examples/python/src (venv)$ python -m demo.calc_server_bug 0 ../trace.log Started server on 0.0.0.0:8080.. detectEr automatically registers the creation of trace.log and starts analysing events right away. It instruments the analyser and promptly analyses the first process event, init . This is translated to the internal Erlang spawned event (see From specification to analyser ). *** [<0.86.0>] Instrumenting monitor for MFA pattern '{calc_server_bug,loop,[0]}'. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,spawned,<0.102.0>,{calc_server_bug,loop,[0]}}. Let us submit an addition request through telnet . [duncan@local]:/detecter/examples/python$ telnet localhost 8080 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. /add 10 97 -87.0 The Erlang shell hosting detectEr shows that this leads to the rejection verdict no , corresponding to a violation of property P 3 . *** [<0.89.0>] Analyzing event {trace,<0.808.0>,'receive',{<0.610.0>,{add,10.0,97.0}}}. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,send,{ok,-87.0},<0.610.0>}. *** [<0.89.0>] Reached verdict 'no'. Stop the server: /stp stopped Connection closed by foreign host. Stop the outline instrumentation. We need to do this since the log is read in a forward-only manner, and rewriting to it disrupts the parsing mechanism. monitor:stop(). The output on the Erlang shell is the same as the one we have seen previously with outline instrumentation, where analysers are terminated promptly upon verdict detection.","title":"Offline instrumentation in action"},{"location":"using-detecter/offline-instrumentation.html#testing-the-correct-server-implementation","text":"Go ahead and test the correct calculator server implementation, calc_server , following the above steps. Remember to remove trace.log prior to starting detectEr in offline mode, otherwise it will process the events from our previous run. When executing /add requests, you should be able to see the offline analyser recurse via variable X . 1> monitor : start_offline ( \"trace.log\" , pid ( 0 , 102 , 0 ), fun prop_add_rec : mfa_spec / 1 , []). init_it: Starter=<0.84.0>, Parent=<0.84.0>, Name={local,log_poller}, Mod=log_poller, Args=[\"trace.log\"], Opts=[] <0.86.0> *** [<0.86.0>] Instrumenting monitor for MFA pattern '{calc_server,loop,[0]}'. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,spawned,<0.102.0>,{calc_server,loop,[0]}}. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,'receive',{<0.612.0>,{add,10.0,97.0}}}. *** [<0.89.0>] Analyzing event {trace,<0.808.0>,send,{ok,107.0},<0.612.0>}. *** [<0.89.0>] Unfolding rec. var. 'X'. Issuing both /mul and /stp requests leads to the inconclusive verdict end . *** [<0.89.0>] Reached verdict 'end' on event {trace,<0.808.0>,'receive',{<0.612.0>,{mul,10.0,97.0}}}. Congratulations on completing this tutorial! Woohoo!","title":"Testing the correct server implementation"},{"location":"using-detecter/outline-instrumentation.html","text":"Outline Instrumentation \u00b6 Overview \u00b6 Outline instrumentation is the non-invasive counterpart to inlining, where no changes are written to the program source code. Outlining externalises the extraction of, and analysis of trace events. It leverages the native tracing infrastructure the the EVM provides. EVM tracing is used by a multitude of other programs and utilities that target the Erlang ecosystem, such as the debugger dbg . The nice thing about Erlang tracing is that is supports any software component that is developed for the EVM . For instance, languages like Elixir and Clojerl can benefit from our type of runtime monitoring. Detailed information about the outline instrumentation algorithm detectEr uses can be found in the companion paper , and our preprint . The calculator server program \u00b6 For this demo, we will use an Elixir implementation of our buggy calculator server that subtracts numbers, rather than adding them. This implementation, shown below, is identical to the one in Erlang in every aspect, except for the programming language syntax. In particular, function invocations in Elixir may omit the parentheses ( e.g. , send , self ), and atoms are prepended with a colon ( e.g. , :add ). Elixir variables are specified in lowercase , as opposed to Erlang, which must be capitalised. Finally, messages in Elixir are sent using the function send , that accepts the PID of the recipient process and the message to be sent as arguments, and is the counterpart to ! in Erlang. def start ( n ) do spawn __MODULE__ , :loop , [ n ] end def loop ( tot ) do receive do { clt , { :add , a , b }} -> # Handle addition request from client. send clt , { :ok , a - b } # Bug!! loop tot + 1 { clt , { :mul , a , b }} -> # Handle multiplication request from client. send clt , { :ok , a * b } loop tot + 1 { clt , :stp } -> # Handle stop request. Server does not loop again. send clt , { :bye , tot } end end The function Demo.CalcServerBug . start / 1 returns the PID , as the case for the Erlang version, while the messages for addition, multiplication and termination requests are the same. Let us familiarise ourselves with this implementation by executing it on the Elixir shell. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to example/elixir . [duncan@local]:/detecter$ cd examples/elixir [duncan@local]:/detecter/examples/elixir$ ls -l -rw-r--r-- 1 duncan duncan 4452 Jun 11 19:56 Makefile drwxr-xr-x@ 3 duncan duncan 96 Apr 29 19:16 lib drwxr-xr-x@ 5 duncan duncan 160 Jun 12 22:10 props Execute make to compile all of the Elixir source code modules located in examples/elixir/lib . A new ebin directory containing the compiled *.beam files is created. Launch the Elixir shell iex . As we did in the Erlang case, we add the detectEr binaries and the ones we just compiled to the shell code path using -pa . By contrast to what we did when launching the Erlang shell, -pa must be prepend each directory we wish to add separately. [duncan@local]:/detecter/examples/elixir$ iex -pa ../../detecter/ebin -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Interactive Elixir (1.11.4) - press Ctrl+C to exit (type h() ENTER for help) iex(1)> The buggy calculator server is started by invoking Demo.CalcServerBug . start / 1 that accepts a single argument, n , that it uses to track the number of requests handled. Like its Erlang counterpart Demo.CalcServerBug . start / 1 returns the server process PID , which we assign to variable pid . iex(1)> pid = Demo.CalcServerBug . start 0 #PID<0.109.0> The server is ready for client requests, which we submit using via send . To add two numbers: iex(2)> send pid , { self , { :add , 10 , 97 }} {#PID<0.106.0>, {:add, 10, 97}} Observe that the request we issued bears the same format as the one used in our Erlang implementation. Once again, note that { #PID<0.106.0>, {:add, 10, 97}} is not the server reply. Multiplying numbers is accomplished analogously. Viewing the server reply from the server is done using flush / 0 . iex(3)> flush {:ok, -87} :ok To shutdown the server, we use stp . iex(4)> send pid , { self , :stp } {#PID<0.106.0>, :stp} iex(5)> flush {:bye, 1} :ok The correct implementation of the server in the Demo.CalcServer module can be launched by following the steps above. Outline instrumentation in action \u00b6 We need to synthesise the analysers from the prop_add_rec.hml in examples/elixir/props . These analysers designate the main calculator server loop functions Demo.CalcServer.loop/1 and Demo.CalcServerBug.loop/1 in their with statement. iex(6)> :hml_eval . compile 'props/prop_add_rec.hml' , [{ :outdir , 'ebin' }, :v ] :ok detectEr provides the monitor module that enables us to instrument the program we want analysed using outlining. This module offers two functions, start_online / 3 , and start_offline / 4 for conducting outline and offline instrumentation. We use former function, and cover monitor : start_offline / 4 in the next section on Offline Instrumentation . start_online / 3 accepts three arguments: the tuple specifying the main function of the program we want instrumented in the format { Mod , Fun , Args } where Mod is the module name, Fun is the main function to be launched, and Args , the list of arguments accepted by Fun , the function mfa_spec / 1 of the analyser we want to use, and, an option list. The options supported by start_online / 3 are: Option Description parent Supervisor process that is linked to tracers, or self if no supervision is required. The supervisor is notified when tracers or analysers terminate their execution, via process linking. If left unspecified, defaults to self . analysis Analysis mode, which can be either internal or external . Internal analysis means that the tracer process and analyser are one and the same; external analysis splits the tracing and analysers into separate processes. If left unspecified, defaults to internal . start_online / 3 returns the triple { ok , Pid , Return } , consisting of the atom ok , the PID of the root tracer Pid , and the Return result of the function specified in { Mod , Fun , Args } . Let us instrument the buggy calculator server, Demo.CalcServerBug , to detect property violations. Launch the buggy server via start_online / 3 . As done above, we need to retain the PID of the calculator server process, which is the value returned by Demo.CalcServerBug . loop / 1 . We pattern match against the return value, and store the PID inside the variable pid . Demo.CalcServerBug . loop / 1 is specified as the tuple { Demo.CalcServerBug , :start , [ 0 ]} , the first argument to start_online / 3 . The second argument is the analyser function :prop_add_rec . mfa_spec / 1 we synthesised earlier, and the list of options is left empty. iex(7)> { :ok , _ , pid } = :monitor . start_online { Demo.CalcServerBug , :start , [ 0 ]}, & :prop_add_rec . mfa_spec / 1 , [] *** [<0.109.0>] Instrumenting monitor for MFA pattern '{'Elixir.Demo.CalcServerBug',loop,[0]}'. *** [<0.111.0>] Analyzing event {trace,<0.110.0>,spawned,<0.108.0>,{'Elixir.Demo.CalcServerBug',loop,[0]}}. {:ok, #PID<0.109.0>, #PID<0.110.0>} As soon as the calculator server process starts, the analyser immediately enters into action and analyses the first process event init . This is translated to the internal Erlang spawned event (see From specification to analyser ). Now, let us try adding two numbers. iex(8)> send pid , { self , { :add , 10 , 97 }} *** [<0.111.0>] Analyzing event {trace,<0.110.0>,'receive',{<0.106.0>,{add,10,97}}}. *** [<0.111.0>] Analyzing event {trace,<0.110.0>,send,{ok,-87},<0.106.0>}. *** [<0.111.0>] Reached verdict 'no'. {#PID<0.106.0>, {:add, 10, 97}} This leads to a rejection verdict no , corresponding to a violation of our property P 3 . Stop the server. iex(9)> send pid , { self , { :add , 10 , 97 }} {#PID<0.106.0>, {:add, 10, 97}} Stop the outline instrumentation. :monitor.stop. Irrevocable verdicts \u00b6 By contrast to the inline case, the recv and send events that were exhibited by the calculator server do not appear when the server terminates in step 4 above. The question is why? In outlining, analysers are promptly terminated when a verdict is flagged, in an effort to make things efficient. This optimisation is possible because the verdicts analysers flag are irrevocable, so an analyser can terminate, safe in the knowledge that whatever verdict it has flagged, it will surely remain so. As a byproduct of analyser termination, no event extraction from the program is possible, which is why the recv and send in step 4 are never observed. The program without analysis. \u00b6 EVM tracing permits analysers to dynamically observe processes. A terminated analyser or one that is never started means that no events from the program are extracted. We can test this by launching the calculator server without going through monitor : start_online / 3 . iex(10)> pid = Demo.CalcServerBug . start 0 #PID<0.120.0> iex(11)> send pid , { self , { :mul , 10 , 97 }} {#PID<0.106.0>, {:mul, 10, 97}} No analysers are instrumented, nor trace events extracted, since outlining never modifies the program. Contrastingly, with inlining, a recompilation of the program is necessary should we want to run that program without instrumentation. The flexibility due to outlining enables us to execute the program with no instrumentation by a mere restart without the need of redeployments. In principle, analysers can also be attached while the program is operating, similar to how debuggers in Erlang work; this is an avenue left for near future work. Testing the correct server implementation \u00b6 Try running the correct server Demo.CalcServer as an exercise. You need to start it as follows. iex(12)> { :ok , _ , pid } = :monitor . start_online { Demo.CalcServer , :start , [ 0 ]}, & :prop_add_rec . mfa_spec / 1 , [] The benefits that outlining offers can be taken a step further with offline instrumentation.","title":"Outline Instrumentation"},{"location":"using-detecter/outline-instrumentation.html#outline-instrumentation","text":"","title":"Outline Instrumentation"},{"location":"using-detecter/outline-instrumentation.html#overview","text":"Outline instrumentation is the non-invasive counterpart to inlining, where no changes are written to the program source code. Outlining externalises the extraction of, and analysis of trace events. It leverages the native tracing infrastructure the the EVM provides. EVM tracing is used by a multitude of other programs and utilities that target the Erlang ecosystem, such as the debugger dbg . The nice thing about Erlang tracing is that is supports any software component that is developed for the EVM . For instance, languages like Elixir and Clojerl can benefit from our type of runtime monitoring. Detailed information about the outline instrumentation algorithm detectEr uses can be found in the companion paper , and our preprint .","title":"Overview"},{"location":"using-detecter/outline-instrumentation.html#the-calculator-server-program","text":"For this demo, we will use an Elixir implementation of our buggy calculator server that subtracts numbers, rather than adding them. This implementation, shown below, is identical to the one in Erlang in every aspect, except for the programming language syntax. In particular, function invocations in Elixir may omit the parentheses ( e.g. , send , self ), and atoms are prepended with a colon ( e.g. , :add ). Elixir variables are specified in lowercase , as opposed to Erlang, which must be capitalised. Finally, messages in Elixir are sent using the function send , that accepts the PID of the recipient process and the message to be sent as arguments, and is the counterpart to ! in Erlang. def start ( n ) do spawn __MODULE__ , :loop , [ n ] end def loop ( tot ) do receive do { clt , { :add , a , b }} -> # Handle addition request from client. send clt , { :ok , a - b } # Bug!! loop tot + 1 { clt , { :mul , a , b }} -> # Handle multiplication request from client. send clt , { :ok , a * b } loop tot + 1 { clt , :stp } -> # Handle stop request. Server does not loop again. send clt , { :bye , tot } end end The function Demo.CalcServerBug . start / 1 returns the PID , as the case for the Erlang version, while the messages for addition, multiplication and termination requests are the same. Let us familiarise ourselves with this implementation by executing it on the Elixir shell. Launch a new terminal emulator window, navigate to the root detectEr directory, and: Change the directory to example/elixir . [duncan@local]:/detecter$ cd examples/elixir [duncan@local]:/detecter/examples/elixir$ ls -l -rw-r--r-- 1 duncan duncan 4452 Jun 11 19:56 Makefile drwxr-xr-x@ 3 duncan duncan 96 Apr 29 19:16 lib drwxr-xr-x@ 5 duncan duncan 160 Jun 12 22:10 props Execute make to compile all of the Elixir source code modules located in examples/elixir/lib . A new ebin directory containing the compiled *.beam files is created. Launch the Elixir shell iex . As we did in the Erlang case, we add the detectEr binaries and the ones we just compiled to the shell code path using -pa . By contrast to what we did when launching the Erlang shell, -pa must be prepend each directory we wish to add separately. [duncan@local]:/detecter/examples/elixir$ iex -pa ../../detecter/ebin -pa ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Interactive Elixir (1.11.4) - press Ctrl+C to exit (type h() ENTER for help) iex(1)> The buggy calculator server is started by invoking Demo.CalcServerBug . start / 1 that accepts a single argument, n , that it uses to track the number of requests handled. Like its Erlang counterpart Demo.CalcServerBug . start / 1 returns the server process PID , which we assign to variable pid . iex(1)> pid = Demo.CalcServerBug . start 0 #PID<0.109.0> The server is ready for client requests, which we submit using via send . To add two numbers: iex(2)> send pid , { self , { :add , 10 , 97 }} {#PID<0.106.0>, {:add, 10, 97}} Observe that the request we issued bears the same format as the one used in our Erlang implementation. Once again, note that { #PID<0.106.0>, {:add, 10, 97}} is not the server reply. Multiplying numbers is accomplished analogously. Viewing the server reply from the server is done using flush / 0 . iex(3)> flush {:ok, -87} :ok To shutdown the server, we use stp . iex(4)> send pid , { self , :stp } {#PID<0.106.0>, :stp} iex(5)> flush {:bye, 1} :ok The correct implementation of the server in the Demo.CalcServer module can be launched by following the steps above.","title":"The calculator server program"},{"location":"using-detecter/outline-instrumentation.html#outline-instrumentation-in-action","text":"We need to synthesise the analysers from the prop_add_rec.hml in examples/elixir/props . These analysers designate the main calculator server loop functions Demo.CalcServer.loop/1 and Demo.CalcServerBug.loop/1 in their with statement. iex(6)> :hml_eval . compile 'props/prop_add_rec.hml' , [{ :outdir , 'ebin' }, :v ] :ok detectEr provides the monitor module that enables us to instrument the program we want analysed using outlining. This module offers two functions, start_online / 3 , and start_offline / 4 for conducting outline and offline instrumentation. We use former function, and cover monitor : start_offline / 4 in the next section on Offline Instrumentation . start_online / 3 accepts three arguments: the tuple specifying the main function of the program we want instrumented in the format { Mod , Fun , Args } where Mod is the module name, Fun is the main function to be launched, and Args , the list of arguments accepted by Fun , the function mfa_spec / 1 of the analyser we want to use, and, an option list. The options supported by start_online / 3 are: Option Description parent Supervisor process that is linked to tracers, or self if no supervision is required. The supervisor is notified when tracers or analysers terminate their execution, via process linking. If left unspecified, defaults to self . analysis Analysis mode, which can be either internal or external . Internal analysis means that the tracer process and analyser are one and the same; external analysis splits the tracing and analysers into separate processes. If left unspecified, defaults to internal . start_online / 3 returns the triple { ok , Pid , Return } , consisting of the atom ok , the PID of the root tracer Pid , and the Return result of the function specified in { Mod , Fun , Args } . Let us instrument the buggy calculator server, Demo.CalcServerBug , to detect property violations. Launch the buggy server via start_online / 3 . As done above, we need to retain the PID of the calculator server process, which is the value returned by Demo.CalcServerBug . loop / 1 . We pattern match against the return value, and store the PID inside the variable pid . Demo.CalcServerBug . loop / 1 is specified as the tuple { Demo.CalcServerBug , :start , [ 0 ]} , the first argument to start_online / 3 . The second argument is the analyser function :prop_add_rec . mfa_spec / 1 we synthesised earlier, and the list of options is left empty. iex(7)> { :ok , _ , pid } = :monitor . start_online { Demo.CalcServerBug , :start , [ 0 ]}, & :prop_add_rec . mfa_spec / 1 , [] *** [<0.109.0>] Instrumenting monitor for MFA pattern '{'Elixir.Demo.CalcServerBug',loop,[0]}'. *** [<0.111.0>] Analyzing event {trace,<0.110.0>,spawned,<0.108.0>,{'Elixir.Demo.CalcServerBug',loop,[0]}}. {:ok, #PID<0.109.0>, #PID<0.110.0>} As soon as the calculator server process starts, the analyser immediately enters into action and analyses the first process event init . This is translated to the internal Erlang spawned event (see From specification to analyser ). Now, let us try adding two numbers. iex(8)> send pid , { self , { :add , 10 , 97 }} *** [<0.111.0>] Analyzing event {trace,<0.110.0>,'receive',{<0.106.0>,{add,10,97}}}. *** [<0.111.0>] Analyzing event {trace,<0.110.0>,send,{ok,-87},<0.106.0>}. *** [<0.111.0>] Reached verdict 'no'. {#PID<0.106.0>, {:add, 10, 97}} This leads to a rejection verdict no , corresponding to a violation of our property P 3 . Stop the server. iex(9)> send pid , { self , { :add , 10 , 97 }} {#PID<0.106.0>, {:add, 10, 97}} Stop the outline instrumentation. :monitor.stop.","title":"Outline instrumentation in action"},{"location":"using-detecter/outline-instrumentation.html#irrevocable-verdicts","text":"By contrast to the inline case, the recv and send events that were exhibited by the calculator server do not appear when the server terminates in step 4 above. The question is why? In outlining, analysers are promptly terminated when a verdict is flagged, in an effort to make things efficient. This optimisation is possible because the verdicts analysers flag are irrevocable, so an analyser can terminate, safe in the knowledge that whatever verdict it has flagged, it will surely remain so. As a byproduct of analyser termination, no event extraction from the program is possible, which is why the recv and send in step 4 are never observed.","title":"Irrevocable verdicts"},{"location":"using-detecter/outline-instrumentation.html#the-program-without-analysis","text":"EVM tracing permits analysers to dynamically observe processes. A terminated analyser or one that is never started means that no events from the program are extracted. We can test this by launching the calculator server without going through monitor : start_online / 3 . iex(10)> pid = Demo.CalcServerBug . start 0 #PID<0.120.0> iex(11)> send pid , { self , { :mul , 10 , 97 }} {#PID<0.106.0>, {:mul, 10, 97}} No analysers are instrumented, nor trace events extracted, since outlining never modifies the program. Contrastingly, with inlining, a recompilation of the program is necessary should we want to run that program without instrumentation. The flexibility due to outlining enables us to execute the program with no instrumentation by a mere restart without the need of redeployments. In principle, analysers can also be attached while the program is operating, similar to how debuggers in Erlang work; this is an avenue left for near future work.","title":"The program without analysis."},{"location":"using-detecter/outline-instrumentation.html#testing-the-correct-server-implementation","text":"Try running the correct server Demo.CalcServer as an exercise. You need to start it as follows. iex(12)> { :ok , _ , pid } = :monitor . start_online { Demo.CalcServer , :start , [ 0 ]}, & :prop_add_rec . mfa_spec / 1 , [] The benefits that outlining offers can be taken a step further with offline instrumentation.","title":"Testing the correct server implementation"},{"location":"using-detecter/runtime-verification.html","text":"Runtime Verification \u00b6 A partial view of the program model \u00b6 Let us recall the calculator server and its transition model. @import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt, stp } Srv ? {Clt,stp} Srv:Clt ! { bye ,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! { ok ,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{ add ,A,B}} Srv ? {Clt,{add,A,B}} Srv:Clt ! { ok ,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{ mul ,A,B}} Srv ? {Clt,{mul,A,B}} Viewer does not support full SVG 1.1 From its initial state Q0 , the transition system modelling the behaviour of calc_server : loop / 1 can follow three different paths. This branching structure is induced by the receive expression, that introduces a choice between which clause to execute, depending on the pattern match that succeeds. The transition model thus gives us an exhaustive description of the paths that the calculator server can take at runtime, affording us full visibility about what the program is able to do. Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon. There are however cases where static approaches cannot be employed, e.g. the program transition model is not available, or is infeasible to construct. Runtime Verification is a post-deployment technique that can be used instead of, or in tandem with, static techniques to increase correctness assurances about a program under scrutiny. RV uses monitors\u2014computational entities consisting of logically-distinct instrumentation and analyser units\u2014to observe the execution of the program under scrutiny. detectEr is one such RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM . Post-deployment verification techniques such as RV often to not have access to the entire transition model of a program. Rather, their view of the system is limited to just to the sequence of events generated by the current program execution. This linear sequence of program event is known as the (execution) trace . For instance, our calculator program might generate the trace of events \u2018 < 0 . 10 . 0 > ? { < 0 . 16 . 0 > , stp } . < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } \u2019. This corresponds to the (finite) path traversal Q0 \u2192 Srv ? { Clt , stp } \u2192 Q3 \u2192 Srv:Clt ! {bye, Tot} in the transition model above, where Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = 1 . Is one execution trace enough? \u00b6 One natural question that may occur to you at this point is whether a mere sliver of the (more expressive) program transition model is sufficient for us to conclude anything of value about the program under analysis. Answers to this question depend on various aspects: What logic are we using to express properties? There are logics that can reason about states of the program transition model ( e.g. \u03bc-calculus, HML, CTL), while others can only reason on traces ( e.g. , LTL). Are the traces we consider finite or infinite? By and large, a number of logics used for model checking reason about infinite traces. RV typically produces finite traces, and this means that such logics need to be semantically adapted to the runtime setting, or studied to determine which subsets of them are amenable to runtime monitoring. How many traces do we have available? There are cases where more than one trace is available, e.g. the program is executed multiple times, or the program consists of concurrent components that produce different interleaved executions. This produces additional runtime information that one may leverage. This field of study is called monitorability , and has been treated at length in various works 1 . For us, it is enough to know that sHML \u2014the logic detectEr uses\u2014is runtime monitorable with respect to violations 2 . Violation Any program that violates a property expressed as a sHML formula can be detected by finding an execution trace that contains the violating program behaviour. The intuition as to why this is the case is as follows. Recall that the sHML formula [ \u03b1 ] \u03c6 requires that all the outgoing paths from some state of the program transition model satisfy the symbolic action \u03b1 , and the next state then satisfies the continuation \u03c6 . To show that a program transition model ( not just one path!) violates the sHML property, it suffices to find one path in the transition model that goes against the what property stipulates. Now, in our runtime setting, the program under scrutiny is sure to follow at least one such path in the model, which is precisely the one it takes as it executes. This path, observable as an execution trace, is processed by runtime analysers to yield monitoring verdicts . In our case of safety properties, the verdict an analyser gives is either no or end : no corresponds to a property violation, ff , end means that the analyser does not have sufficient information in the trace to be able to conclude whether the program violates the property. This is the case, since there might be other traces ( i.e. , other paths in the program transition model) that can contain the violating behaviour. We refer to this type of verdict as an inconclusive verdict . The verdicts that runtime analysers flag are irrevocable . These are verdicts that once given, cannot be retracted and changed. For our purposes, this makes sense. Why? Because in the case of safety properties, an analyser that changes its verdict, sometimes flagging no and at other times, end , would be useless. We want that if the program violates a property, then it stays that way, and the analyser persists its given verdict. Note Often it is assumed that the program and model correspond, i.e. , the program model captures the behaviour of the program implementation. In the sequel, whenever we say that the program (or program implementation) violates a stipulated property, it also means that the model violates that property. We next learn how runtime analysers from sHML specifications can be synthesised. Citations needed \u21a9 Citations needed \u21a9","title":"Runtime Verification"},{"location":"using-detecter/runtime-verification.html#runtime-verification","text":"","title":"Runtime Verification"},{"location":"using-detecter/runtime-verification.html#a-partial-view-of-the-program-model","text":"Let us recall the calculator server and its transition model. @import url(https://fonts.googleapis.com/css?family=Fira+Code);&#xa; Q1 Q1 Q4 Q4 Q0 Q0 Q3 Q3 Q2 Q2 Srv ? {Clt, stp } Srv ? {Clt,stp} Srv:Clt ! { bye ,Tot} Srv:Clt ! {bye,Tot} Srv:Clt ! { ok ,{A+B}} Srv:Clt ! {ok,{A+B}} Srv ? { Clt ,{ add ,A,B}} Srv ? {Clt,{add,A,B}} Srv:Clt ! { ok ,{A*B}} Srv:Clt ! {ok,{A*B}} Srv ? {Clt,{ mul ,A,B}} Srv ? {Clt,{mul,A,B}} Viewer does not support full SVG 1.1 From its initial state Q0 , the transition system modelling the behaviour of calc_server : loop / 1 can follow three different paths. This branching structure is induced by the receive expression, that introduces a choice between which clause to execute, depending on the pattern match that succeeds. The transition model thus gives us an exhaustive description of the paths that the calculator server can take at runtime, affording us full visibility about what the program is able to do. Notably, this information is available prior to runtime, and is what certain static verification techniques such as model checking rely upon. There are however cases where static approaches cannot be employed, e.g. the program transition model is not available, or is infeasible to construct. Runtime Verification is a post-deployment technique that can be used instead of, or in tandem with, static techniques to increase correctness assurances about a program under scrutiny. RV uses monitors\u2014computational entities consisting of logically-distinct instrumentation and analyser units\u2014to observe the execution of the program under scrutiny. detectEr is one such RV tool for asynchronous component systems that can analyse the behaviour of programs running on, or outside the EVM . Post-deployment verification techniques such as RV often to not have access to the entire transition model of a program. Rather, their view of the system is limited to just to the sequence of events generated by the current program execution. This linear sequence of program event is known as the (execution) trace . For instance, our calculator program might generate the trace of events \u2018 < 0 . 10 . 0 > ? { < 0 . 16 . 0 > , stp } . < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } \u2019. This corresponds to the (finite) path traversal Q0 \u2192 Srv ? { Clt , stp } \u2192 Q3 \u2192 Srv:Clt ! {bye, Tot} in the transition model above, where Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = 1 .","title":"A partial view of the program model"},{"location":"using-detecter/runtime-verification.html#is-one-execution-trace-enough","text":"One natural question that may occur to you at this point is whether a mere sliver of the (more expressive) program transition model is sufficient for us to conclude anything of value about the program under analysis. Answers to this question depend on various aspects: What logic are we using to express properties? There are logics that can reason about states of the program transition model ( e.g. \u03bc-calculus, HML, CTL), while others can only reason on traces ( e.g. , LTL). Are the traces we consider finite or infinite? By and large, a number of logics used for model checking reason about infinite traces. RV typically produces finite traces, and this means that such logics need to be semantically adapted to the runtime setting, or studied to determine which subsets of them are amenable to runtime monitoring. How many traces do we have available? There are cases where more than one trace is available, e.g. the program is executed multiple times, or the program consists of concurrent components that produce different interleaved executions. This produces additional runtime information that one may leverage. This field of study is called monitorability , and has been treated at length in various works 1 . For us, it is enough to know that sHML \u2014the logic detectEr uses\u2014is runtime monitorable with respect to violations 2 . Violation Any program that violates a property expressed as a sHML formula can be detected by finding an execution trace that contains the violating program behaviour. The intuition as to why this is the case is as follows. Recall that the sHML formula [ \u03b1 ] \u03c6 requires that all the outgoing paths from some state of the program transition model satisfy the symbolic action \u03b1 , and the next state then satisfies the continuation \u03c6 . To show that a program transition model ( not just one path!) violates the sHML property, it suffices to find one path in the transition model that goes against the what property stipulates. Now, in our runtime setting, the program under scrutiny is sure to follow at least one such path in the model, which is precisely the one it takes as it executes. This path, observable as an execution trace, is processed by runtime analysers to yield monitoring verdicts . In our case of safety properties, the verdict an analyser gives is either no or end : no corresponds to a property violation, ff , end means that the analyser does not have sufficient information in the trace to be able to conclude whether the program violates the property. This is the case, since there might be other traces ( i.e. , other paths in the program transition model) that can contain the violating behaviour. We refer to this type of verdict as an inconclusive verdict . The verdicts that runtime analysers flag are irrevocable . These are verdicts that once given, cannot be retracted and changed. For our purposes, this makes sense. Why? Because in the case of safety properties, an analyser that changes its verdict, sometimes flagging no and at other times, end , would be useless. We want that if the program violates a property, then it stays that way, and the analyser persists its given verdict. Note Often it is assumed that the program and model correspond, i.e. , the program model captures the behaviour of the program implementation. In the sequel, whenever we say that the program (or program implementation) violates a stipulated property, it also means that the model violates that property. We next learn how runtime analysers from sHML specifications can be synthesised. Citations needed \u21a9 Citations needed \u21a9","title":"Is one execution trace enough?"},{"location":"using-detecter/synthesising-analysers.html","text":"Synthesising Analysers \u00b6 Trace events, in practice \u00b6 When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework. To disentangle the specification and analysis concepts, detectEr employs the intermediate representation seen earlier , consisting of the program events, fork , init , exit , send and recv . These intermediate events are internally translated to the ones that the native Erlang tracing infrastructure uses. We adopt this approach since it simplifies the implementation of analysers. From specification to analyser \u00b6 To demonstrate how you can use detectEr to synthesise analysers, we use the formalisation of property P 3 as a vehicle. detectEr provides the hml_eval : compile / 2 function that compiles sHML specifications to executable Erlang code. The compile function accepts two arguments, the path that points to the sHML script file, and a list of options that control how the resulting analyser is generated. sHML script files are plain text formatted files with a .hml extension, and must at least contain one specification. Multiple specifications are separated with comma, and every file must be terminated with a full-stop. The configuration options that hml_eval : compile / 2 are as follows. Option Description outdir Directory where the synthesised analyser file should be written. If left unspecified, defaults to the current directory . . v Inserts logging statements into the synthesised output analyser file. Only use for debugging purposes. erl Instructs compile function to output the synthesised analyser as Erlang source code rather than in beam format. If left unspecified, defaults to beam . Analysers are synthesised from the Erlang shell, which needs to have the detectEr binaries loaded in its code path. This is done by launching the shell with the -pa flag. For this example, we change the directory to examples/erlang and launch the Erlang shell, of course assuming that the detectEr source files have already been compiled. Refer to the section Setting up detectEr if you need to do this. [duncan@local]:$ cd examples/erlang [duncan@local]:$ erl -pa ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> With the Erlang shell loaded, compile the prop_add_rec.hml . 1> hml_eval : compile ( \"props/prop_add_rec.hml\" , [{ outdir , \"ebin\" }, erl ]). ok We have specified the erl option to generate the analyser source code in order to overview the internal workings of analysers. You may skip this section if you want just learn how to to use the tool. The analyser is written in the file ebin/prop_add_rec.erl , an excerpt of which is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 - module ( prop_add_rec ). - author ( \"detectEr\" ). - generated ( \"2021/6/12 16:51:08\" ). - export ([ mfa_spec / 1 ]). mfa_spec ({ calc_server , loop , [_]}) -> { ok , fun ({ trace , _, spawned , _, { calc_server , loop , [_]}}) -> fun X () -> fun ({ trace , _, 'receive' , {_, { add , A , B }}}) -> fun ({ trace , _, send , { ok , Res }, _}) when Res =/= A + B -> no ; ({ trace , _, send , { ok , Res }, _}) when Res =:= A + B -> X (); (_) -> 'end' end ; (_) -> 'end' end end (); (_) -> 'end' end }; mfa_spec ({ calc_server_bug , loop , [_]}) -> ... ... end }; mfa_spec (_) -> undefined . So the first thing that we should note is that the analyser is one higher-order function returns other functions or atoms in turn. The init , send , recv event patterns in the specification are translated by hml_eval : compile / 2 to the event format that the EVM uses for tracing. These event mappings are tabled below. Program event Pattern EVM trace event translation fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawn , P\u2082 , { Mod , Fun , Args }} init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawned , P\u2082 , { Mod , Fun , Args }} exit P\u2081 ** Reason { trace , P\u2081 , exit , Reason } send P\u2081 : P\u2082 ! Msg { trace , P\u2081 , send , Msg , P\u2082 } recv P\u2082 ? Msg { trace , P\u2081 , 'receive' , Msg } The entry point to analysers is the hardcoded function mfa_spec / 1 that accepts as an argument the function that we designated with the keyword with , line 5 . We revisit mfa_spec / 1 when we discuss the instrumentation. In the specific case of our calculator server example, the targeted function on line 5 is loop in the calc_server module. Our examples packaged with the detectEr distribution include a second implementation of a buggy calculator server, calc_server_bug , which we will use to show how analysers flag rejection verdicts. prop_add_rec.hml specifies the same formalisation of P 3 for this buggy version, the corresponding synthesised analyser code is given on lines 24 - 27 (omitted). We will use this second analyser to show how a rejection verdict is reached when incorrect program behaviour is detected. Our analysers behave similar to state machines that analyse events and transition to the next state that corresponds to the continuation formula. In the analyser code above, the necessity with the init symbolic action, and ([_ <- _, calc_server : loop (_)] , in our sHML formula corresponds to the function clause on line 7 . Next comes the maximal fix-point construct that is translated to the named function X , line 8 . The name X is used to recurse when the send event pattern matches to the correct reply consisting of the addition of the variables A and B . Nested inside X is the function on lines 9 - 19 that corresponds to the first necessity containing the receive process pattern _ ? {_, { add , A , B }} . Finally, we have the analyser code for the two necessities that handle the incorrect and correct cases of addition, both enclosed in the parent function that handles recv . This function consists of two clauses. The constraint when Res =/= A + B in the first clause is satisfied when the reply payload sent by the server contains anything other than the sum of A and B , leading to a rejection verdict no (line 11 ). The second clause on line 12 corresponds to the necessity [_:_ ! { ok , Res } when Res =:= A + B ] , handling the case when the addition is correctly executed by the server. Note that the body of the latter function is just the invocation of the outer function X , which emulates looping via recursion. The functions we discussed each have an extra \u2018catch all\u2019 clause that is inserted by the synthesiser ( e.g. , lines 14 , 17 ) to cater for the case where the event reported to the analyser is not the one expected. This clause matches any other event, hence the use of the don\u2019t care pattern _ . In such instances, the analyser is unable to decide whether that event leads to a rejection verdict, i.e. , a violation of the property. Not also that since the functions are nested withing each other, the variables in the outer functions bind the ones in the inner functions. This lexical scoping is what allows us to refer to the variables A and B of the receive pattern _ ? {_, { add , A , B }} in the first necessity, from the constraints of the second necessities, when Res =/= A + B and when Res =:= A + B . Executable analysers \u00b6 Now that we have seen what the analyser looks like from the inside, we can go ahead and recompile prop_add_rec.hml script, this time replacing the erl option for v . Verbose analysers print the events they analyse on the Erlang shell. Of course, the resulting analyser binary must be included in the code path of the program we are running, together with the detectEr binaries. This will be instructive to help understand what happens when we instrument and runtime analyse the correct and buggy versions of our calculator server. 2> hml_eval : compile ( \"props/prop_add_rec.hml\" , [{ outdir , \"ebin\" }, v ]). ok Now we look at the kinds of instrumentation methods detectEr offers.","title":"Synthesising Analysers"},{"location":"using-detecter/synthesising-analysers.html#synthesising-analysers","text":"","title":"Synthesising Analysers"},{"location":"using-detecter/synthesising-analysers.html#trace-events-in-practice","text":"When it comes to tooling, the representation of trace events tends to be implementation-specific and is often tied to the chosen language framework. To disentangle the specification and analysis concepts, detectEr employs the intermediate representation seen earlier , consisting of the program events, fork , init , exit , send and recv . These intermediate events are internally translated to the ones that the native Erlang tracing infrastructure uses. We adopt this approach since it simplifies the implementation of analysers.","title":"Trace events, in practice"},{"location":"using-detecter/synthesising-analysers.html#from-specification-to-analyser","text":"To demonstrate how you can use detectEr to synthesise analysers, we use the formalisation of property P 3 as a vehicle. detectEr provides the hml_eval : compile / 2 function that compiles sHML specifications to executable Erlang code. The compile function accepts two arguments, the path that points to the sHML script file, and a list of options that control how the resulting analyser is generated. sHML script files are plain text formatted files with a .hml extension, and must at least contain one specification. Multiple specifications are separated with comma, and every file must be terminated with a full-stop. The configuration options that hml_eval : compile / 2 are as follows. Option Description outdir Directory where the synthesised analyser file should be written. If left unspecified, defaults to the current directory . . v Inserts logging statements into the synthesised output analyser file. Only use for debugging purposes. erl Instructs compile function to output the synthesised analyser as Erlang source code rather than in beam format. If left unspecified, defaults to beam . Analysers are synthesised from the Erlang shell, which needs to have the detectEr binaries loaded in its code path. This is done by launching the shell with the -pa flag. For this example, we change the directory to examples/erlang and launch the Erlang shell, of course assuming that the detectEr source files have already been compiled. Refer to the section Setting up detectEr if you need to do this. [duncan@local]:$ cd examples/erlang [duncan@local]:$ erl -pa ../../detecter/ebin Erlang/OTP 23 [erts-11.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe] [dtrace] Eshell V11.2.1 (abort with ^G) 1> With the Erlang shell loaded, compile the prop_add_rec.hml . 1> hml_eval : compile ( \"props/prop_add_rec.hml\" , [{ outdir , \"ebin\" }, erl ]). ok We have specified the erl option to generate the analyser source code in order to overview the internal workings of analysers. You may skip this section if you want just learn how to to use the tool. The analyser is written in the file ebin/prop_add_rec.erl , an excerpt of which is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 - module ( prop_add_rec ). - author ( \"detectEr\" ). - generated ( \"2021/6/12 16:51:08\" ). - export ([ mfa_spec / 1 ]). mfa_spec ({ calc_server , loop , [_]}) -> { ok , fun ({ trace , _, spawned , _, { calc_server , loop , [_]}}) -> fun X () -> fun ({ trace , _, 'receive' , {_, { add , A , B }}}) -> fun ({ trace , _, send , { ok , Res }, _}) when Res =/= A + B -> no ; ({ trace , _, send , { ok , Res }, _}) when Res =:= A + B -> X (); (_) -> 'end' end ; (_) -> 'end' end end (); (_) -> 'end' end }; mfa_spec ({ calc_server_bug , loop , [_]}) -> ... ... end }; mfa_spec (_) -> undefined . So the first thing that we should note is that the analyser is one higher-order function returns other functions or atoms in turn. The init , send , recv event patterns in the specification are translated by hml_eval : compile / 2 to the event format that the EVM uses for tracing. These event mappings are tabled below. Program event Pattern EVM trace event translation fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawn , P\u2082 , { Mod , Fun , Args }} init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) { trace , P\u2081 , spawned , P\u2082 , { Mod , Fun , Args }} exit P\u2081 ** Reason { trace , P\u2081 , exit , Reason } send P\u2081 : P\u2082 ! Msg { trace , P\u2081 , send , Msg , P\u2082 } recv P\u2082 ? Msg { trace , P\u2081 , 'receive' , Msg } The entry point to analysers is the hardcoded function mfa_spec / 1 that accepts as an argument the function that we designated with the keyword with , line 5 . We revisit mfa_spec / 1 when we discuss the instrumentation. In the specific case of our calculator server example, the targeted function on line 5 is loop in the calc_server module. Our examples packaged with the detectEr distribution include a second implementation of a buggy calculator server, calc_server_bug , which we will use to show how analysers flag rejection verdicts. prop_add_rec.hml specifies the same formalisation of P 3 for this buggy version, the corresponding synthesised analyser code is given on lines 24 - 27 (omitted). We will use this second analyser to show how a rejection verdict is reached when incorrect program behaviour is detected. Our analysers behave similar to state machines that analyse events and transition to the next state that corresponds to the continuation formula. In the analyser code above, the necessity with the init symbolic action, and ([_ <- _, calc_server : loop (_)] , in our sHML formula corresponds to the function clause on line 7 . Next comes the maximal fix-point construct that is translated to the named function X , line 8 . The name X is used to recurse when the send event pattern matches to the correct reply consisting of the addition of the variables A and B . Nested inside X is the function on lines 9 - 19 that corresponds to the first necessity containing the receive process pattern _ ? {_, { add , A , B }} . Finally, we have the analyser code for the two necessities that handle the incorrect and correct cases of addition, both enclosed in the parent function that handles recv . This function consists of two clauses. The constraint when Res =/= A + B in the first clause is satisfied when the reply payload sent by the server contains anything other than the sum of A and B , leading to a rejection verdict no (line 11 ). The second clause on line 12 corresponds to the necessity [_:_ ! { ok , Res } when Res =:= A + B ] , handling the case when the addition is correctly executed by the server. Note that the body of the latter function is just the invocation of the outer function X , which emulates looping via recursion. The functions we discussed each have an extra \u2018catch all\u2019 clause that is inserted by the synthesiser ( e.g. , lines 14 , 17 ) to cater for the case where the event reported to the analyser is not the one expected. This clause matches any other event, hence the use of the don\u2019t care pattern _ . In such instances, the analyser is unable to decide whether that event leads to a rejection verdict, i.e. , a violation of the property. Not also that since the functions are nested withing each other, the variables in the outer functions bind the ones in the inner functions. This lexical scoping is what allows us to refer to the variables A and B of the receive pattern _ ? {_, { add , A , B }} in the first necessity, from the constraints of the second necessities, when Res =/= A + B and when Res =:= A + B .","title":"From specification to analyser"},{"location":"using-detecter/synthesising-analysers.html#executable-analysers","text":"Now that we have seen what the analyser looks like from the inside, we can go ahead and recompile prop_add_rec.hml script, this time replacing the erl option for v . Verbose analysers print the events they analyse on the Erlang shell. Of course, the resulting analyser binary must be included in the code path of the program we are running, together with the detectEr binaries. This will be instructive to help understand what happens when we instrument and runtime analyse the correct and buggy versions of our calculator server. 2> hml_eval : compile ( \"props/prop_add_rec.hml\" , [{ outdir , \"ebin\" }, v ]). ok Now we look at the kinds of instrumentation methods detectEr offers.","title":"Executable analysers"},{"location":"using-detecter/the-specification-logic.html","text":"The Specification Logic sHML \u00b6 Overview \u00b6 For the sake of simplicity, the script hello_prop.hml used in our hello world example specifies a sHML property that every system necessarily violates, namely, the formula ff that denotes falsity. We now look at the full sHML grammar that enables us to express more interesting and useful properties about programs (not traces). Specifications in sHML \u2014also called formulae \u2014are interpreted over the states of transition models of programs we wish to analyse. sHML is a syntactic subset of the more expressive Hennessy-Milner Logic with recursion, and is used to specify safety properties . Recall safety properties state that \u201csomething bad should never happen\u201d. sHML formulae are generated from the following grammar: \u03c6 \u2208 sHML :: = ff | tt (1) | X (2) | max ( X . \u03c6 ) (3) | and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) (4) Formulae ff and tt denote falsity and truth respectively, X is a logical variable , The maximal fix-point construct specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula \u03c6 , and, and (...) is a sequence of comma-separated conjunctions where each conjunct is a sub-formula \u03c6\u1d62 guarded by the universal modal operator [ \u03b1\u1d62 ] (also called a necessity ). To handle reasoning over program event data, the modal operator is equipped with symbolic actions \u03b1 of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula \u03c6 . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. Central to the conjuncted necessities construct, and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) , is the constraint that at any one point in time, at most one conjunct [ \u03b1\u1d62 ] \u03c6\u1d62 may be satisfied. This enables detectEr to synthesise deterministic analyser code [Refs:Antoins,IAN,TutPaper]. We say that a program (or a program state) satisfies the formula [ P when C ] \u03c6 whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies \u03c6 . When the constraint is true , the expression when C may be omitted for readability. Pattern and constraint expressions \u00b6 detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P\u2081 ** Reason P\u2081 PID of the terminated process Reason Termination reason send P\u2081 : P\u2082 ! Msg P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv P\u2082 ? Msg P\u2082 PID of the recipient process Msg Message payload The variables P\u2081 and P\u2082 in event patterns must be a port ID or PID , whereas Reason and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse . A simple example \u00b6 Let us try to specify a safety requirement on the behaviour of our calculator program . The sHML formula with symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 describes the property requiring that \u201cthe program state does not exhibit a send event whose payload consists of { bye , Tot } with a negative total: and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] \u03c6 , the ensuing program behaviour must then satisfy the continuation formula \u03c6 . However, no program state can satisfy the continuation ff ! This means that the formula and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff can only be satisfied when our calculator program does not exhibit the event described by the symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 . Suppose our server with PID < 0 . 10 . 0 > exhibits the send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , - 1 } in response to a request issued by a client with PID < 0 . 16 . 0 > . It matches pattern Srv : Clt ! { bye , Tot } , instantiating the variables Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = - 1 . The constraint when Tot < 0 is also satisfied by Tot , leading to a violation, i.e. , ff . For a different send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } , the symbolic action in the modality [ Srv : Clt ! { bye , Tot } when Tot < 0 ] is not satisfied, and consequently, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff is not violated. Analogously, the exit event < 0 . 10 . 0 > ** killed does not lead to a violation of the formula since the pattern Srv : Clt ! { bye , Tot } fails to match the event shape. Cheat sheet The formula [ \u03b1 ] ff means that the program must not perform the symbolic action \u03b1 . We next learn how the safety properties P 1 , P 2 , P 3 , and P 4 stated informally can be expressed in sHML .","title":"The Specification Logic"},{"location":"using-detecter/the-specification-logic.html#the-specification-logic-shml","text":"","title":"The Specification Logic sHML"},{"location":"using-detecter/the-specification-logic.html#overview","text":"For the sake of simplicity, the script hello_prop.hml used in our hello world example specifies a sHML property that every system necessarily violates, namely, the formula ff that denotes falsity. We now look at the full sHML grammar that enables us to express more interesting and useful properties about programs (not traces). Specifications in sHML \u2014also called formulae \u2014are interpreted over the states of transition models of programs we wish to analyse. sHML is a syntactic subset of the more expressive Hennessy-Milner Logic with recursion, and is used to specify safety properties . Recall safety properties state that \u201csomething bad should never happen\u201d. sHML formulae are generated from the following grammar: \u03c6 \u2208 sHML :: = ff | tt (1) | X (2) | max ( X . \u03c6 ) (3) | and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) (4) Formulae ff and tt denote falsity and truth respectively, X is a logical variable , The maximal fix-point construct specifies recursion via the logical variable X and binds the free occurrences of X in the sub-formula \u03c6 , and, and (...) is a sequence of comma-separated conjunctions where each conjunct is a sub-formula \u03c6\u1d62 guarded by the universal modal operator [ \u03b1\u1d62 ] (also called a necessity ). To handle reasoning over program event data, the modal operator is equipped with symbolic actions \u03b1 of the form P when C , where P is an event pattern and C , a decidable Boolean constraint . Patterns correspond to events that the program under analysis exhibits. These patterns contain data variables that are instantiated with values learnt at runtime from matched events. Pattern variables bind the free variables in constraints C , and this binding scope extends to the continuation formula \u03c6 . Symbolic action patterns follow the pattern-matching syntax of Erlang and Elixir, where atoms are matched directly, and the \u2018don\u2019t care\u2019 pattern _ matches any data value. Central to the conjuncted necessities construct, and ([ \u03b1\u2081 ] \u03c6\u2081 , ..., [ \u03b1\u2099 ] \u03c6\u2099 ) , is the constraint that at any one point in time, at most one conjunct [ \u03b1\u1d62 ] \u03c6\u1d62 may be satisfied. This enables detectEr to synthesise deterministic analyser code [Refs:Antoins,IAN,TutPaper]. We say that a program (or a program state) satisfies the formula [ P when C ] \u03c6 whenever it exhibits an event that matches pattern P , fulfils the constraint C , and the ensuing program behaviour then satisfies \u03c6 . When the constraint is true , the expression when C may be omitted for readability.","title":"Overview"},{"location":"using-detecter/the-specification-logic.html#pattern-and-constraint-expressions","text":"detectEr supports five event patterns describing the lifecycle of processes. A fork action is exhibited by a process when it spawns a new child process; its dual, init , is exhibited by the corresponding child upon initialisation. Process exit actions signal termination, while send and recv describe process interaction. Program event Event pattern Pattern variable Description fork P\u2081 \u2192 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments init P\u2081 \u2190 P\u2082 , Mod : Fun ( Args ) P\u2081 PID of the parent process spawning P\u2082 P\u2082 PID of the child process spawned by P\u2081 Mod : Fun ( Args ) Function signature consisting of the module, function and arguments exit P\u2081 ** Reason P\u2081 PID of the terminated process Reason Termination reason send P\u2081 : P\u2082 ! Msg P\u2081 PID of the process issuing the message P\u2082 PID of the recipient process Msg Message payload recv P\u2082 ? Msg P\u2082 PID of the recipient process Msg Message payload The variables P\u2081 and P\u2082 in event patterns must be a port ID or PID , whereas Reason and Msg may be any Erlang data type , i.e. , one of atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Mod and Fun must be atoms, and Args , an arbitrary list comprised of the aforementioned data types. Pattern matching Our current detectEr syntax does not yet implement full Erlang pattern matching, including $, map, record and bit string expressions; these will be added in future releases of the tool. Note that these data values can still be used in patterns, so long as the pattern matching expression does not unwrap the individual data components of these values. For instance, the pattern Var = Map is acceptable whereas #{K := V} = Map is not; similarly, Var = List may be used but not [$d, $a | _] = List . Constraint definitions on pattern variables used by detectEr correspond to Erlang guard sequences consisting of guard expressions . The set of valid Erlang guards supported by detectEr are the following: Variables. Values, i.e. , atom, Boolean, integer, float, string, bit string, reference, fun, port ID, PID , tuple, map, and list. Expressions constructing atoms, integer, floats, lists, and tuples. Term comparisons. Operator Description == Equal to /= Not equal to =< Less than or equal to < Less than >= Greater than or equal to > Greater than =:= Exactly equal to =/= Exactly not equal to Arithmetic expressions. Operator Description Argument Type + Unary addition Number - Unary subtraction Number + Addition Number - Subtraction Number * Multiplication Number / Floating point division Number bnot Unary bitwise NOT Integer div Integer division Integer rem Integer remainder of X/Y Integer band Bitwise AND Integer bor Bitwise OR Integer bxor Arithmetic bitwise XOR Integer bsl Arithmetic bit shift left Integer bsr Bit shift right Integer Boolean expressions. Operator Description not Unary logical NOT and Logical AND or Logical OR xor Logical XOR Short-circuit expressions andalso , orelse .","title":"Pattern and constraint expressions"},{"location":"using-detecter/the-specification-logic.html#a-simple-example","text":"Let us try to specify a safety requirement on the behaviour of our calculator program . The sHML formula with symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 describes the property requiring that \u201cthe program state does not exhibit a send event whose payload consists of { bye , Tot } with a negative total: and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff Recall that the universal modality states that, for any program event satisfying the symbolic action P when C in [ P when C ] \u03c6 , the ensuing program behaviour must then satisfy the continuation formula \u03c6 . However, no program state can satisfy the continuation ff ! This means that the formula and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff can only be satisfied when our calculator program does not exhibit the event described by the symbolic action Srv : Clt ! { bye , Tot } when Tot < 0 . Suppose our server with PID < 0 . 10 . 0 > exhibits the send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , - 1 } in response to a request issued by a client with PID < 0 . 16 . 0 > . It matches pattern Srv : Clt ! { bye , Tot } , instantiating the variables Srv = < 0 . 10 . 0 > , Clt = < 0 . 16 . 0 > , and Tot = - 1 . The constraint when Tot < 0 is also satisfied by Tot , leading to a violation, i.e. , ff . For a different send event < 0 . 10 . 0 > : < 0 . 16 . 0 > ! { bye , 1 } , the symbolic action in the modality [ Srv : Clt ! { bye , Tot } when Tot < 0 ] is not satisfied, and consequently, and ([ Srv : Clt ! { bye , Tot } when Tot < 0 ]) ff is not violated. Analogously, the exit event < 0 . 10 . 0 > ** killed does not lead to a violation of the formula since the pattern Srv : Clt ! { bye , Tot } fails to match the event shape. Cheat sheet The formula [ \u03b1 ] ff means that the program must not perform the symbolic action \u03b1 . We next learn how the safety properties P 1 , P 2 , P 3 , and P 4 stated informally can be expressed in sHML .","title":"A simple example"}]}